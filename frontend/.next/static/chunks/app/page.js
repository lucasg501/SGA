/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./app/page.js":
/*!*********************!*\
  !*** ./app/page.js ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_httpClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/httpClient */ \"(app-pages-browser)/./app/utils/httpClient.js\");\n/* harmony import */ var qrcode_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! qrcode.react */ \"(app-pages-browser)/./node_modules/qrcode.react/lib/esm/index.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction Home() {\n    _s();\n    const cpfLocatario = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [cpfFormatado, setCpfFormatado] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [listaParcelas, setListaParcelas] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [parcelaQRAtiva, setParcelaQRAtiva] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [dadosPix, setDadosPix] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    function formatarCPF(valor) {\n        return valor.replace(/\\D/g, \"\") // remove não números\n        .slice(0, 11) // máximo 11 dígitos\n        .replace(/(\\d{3})(\\d)/, \"$1.$2\").replace(/(\\d{3})(\\d)/, \"$1.$2\").replace(/(\\d{3})(\\d{1,2})$/, \"$1-$2\");\n    }\n    function handleChangeCPF(e) {\n        setCpfFormatado(formatarCPF(e.target.value));\n    }\n    // Carregar dados PIX do backend\n    function carregarDadosPix() {\n        return _utils_httpClient__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get('/usuarios/listarChave').then((r)=>{\n            if (r.status === 200) return r.json();\n            alert('Erro ao listar chaves.');\n            return null;\n        }).then((data)=>{\n            if (data && data.length > 0) {\n                setDadosPix(data[0]);\n                return data[0];\n            }\n            return null;\n        });\n    }\n    function procurarParcelas(cpfFormatado) {\n        const cpfLimpo = cpfFormatado.replace(/\\D/g, \"\"); // remove pontos e traço\n        _utils_httpClient__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(\"/aluguel/obterAlugueis/\".concat(cpfLimpo)).then((r)=>{\n            if (r.status === 200) {\n                return r.json();\n            } else {\n                alert('Erro ao listar parcelas.');\n                return null;\n            }\n        }).then((data)=>{\n            if (!data || data.length === 0) {\n                alert('Nenhuma parcela encontrada.');\n                setListaParcelas([]);\n            } else {\n                setListaParcelas(data);\n            }\n        });\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            carregarDadosPix();\n        }\n    }[\"Home.useEffect\"], []);\n    // Calcula CRC16 CCITT-FALSE (padrão PIX)\n    function calcularCRC16(str) {\n        let crc = 0xFFFF;\n        for(let i = 0; i < str.length; i++){\n            crc ^= str.charCodeAt(i) << 8;\n            for(let j = 0; j < 8; j++){\n                if ((crc & 0x8000) !== 0) {\n                    crc = crc << 1 ^ 0x1021;\n                } else {\n                    crc <<= 1;\n                }\n                crc &= 0xFFFF;\n            }\n        }\n        return crc.toString(16).toUpperCase().padStart(4, '0');\n    }\n    function gerarPayloadPix(valor) {\n        let chavePix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (dadosPix === null || dadosPix === void 0 ? void 0 : dadosPix.chavePix) ? dadosPix.chavePix.startsWith('+') ? dadosPix.chavePix : '+55' + dadosPix.chavePix : \"+5518996570042\", nomeRecebedor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (dadosPix === null || dadosPix === void 0 ? void 0 : dadosPix.nomePix) || \"LUCAS GOIS\";\n        console.log(chavePix, nomeRecebedor);\n        const valorFormatado = parseFloat(valor).toFixed(2);\n        const cidade = \"PRES PRUDENTE\";\n        const nome = nomeRecebedor.substring(0, 25).toUpperCase();\n        const cidadeLimite = cidade.substring(0, 15).toUpperCase();\n        const gui = \"BR.GOV.BCB.PIX\";\n        const infoAdicional = \"***\";\n        const merchantAccountInfo = \"00\" + gui.length.toString().padStart(2, '0') + gui + \"01\" + chavePix.length.toString().padStart(2, '0') + chavePix;\n        const campo26 = \"26\" + merchantAccountInfo.length.toString().padStart(2, '0') + merchantAccountInfo;\n        const payloadSemCRC = \"000201\" + campo26 + \"52040000\" + \"5303986\" + \"54\" + valorFormatado.length.toString().padStart(2, '0') + valorFormatado + \"5802BR\" + \"59\" + nome.length.toString().padStart(2, '0') + nome + \"60\" + cidadeLimite.length.toString().padStart(2, '0') + cidadeLimite + \"62\" + \"07\" + \"05\" + infoAdicional.length.toString().padStart(2, '0') + infoAdicional + \"6304\";\n        const crc = calcularCRC16(payloadSemCRC);\n        return payloadSemCRC + crc;\n    }\n    function fecharModal() {\n        setParcelaQRAtiva(null);\n    }\n    function formatarData(dataVencimento) {\n        return new Date(dataVencimento).toLocaleDateString('pt-BR', {\n            day: '2-digit',\n            month: '2-digit',\n            year: 'numeric'\n        });\n    }\n    // Calcula valor com multa de 2% ao mês e juros de 1% ao dia para parcelas atrasadas\n    function calcularValorComMulta(valorOriginal, dataVencimento) {\n        const hoje = new Date();\n        const venc = new Date(dataVencimento);\n        if (hoje <= venc) return parseFloat(valorOriginal);\n        const diffTime = hoje - venc;\n        const diffDias = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n        // Multa de 2% ao mês = 2% / 30 dias por dia atrasado\n        const multaDiaria = 0.02 / 30;\n        const multa = valorOriginal * multaDiaria * diffDias;\n        // Juros de 1% por dia\n        const juros = valorOriginal * 0.01 * diffDias;\n        return parseFloat(valorOriginal) + multa + juros;\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                style: {\n                    textAlign: \"center\"\n                },\n                children: \"Verificar as parcelas pelo CPF\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                lineNumber: 152,\n                columnNumber: 7\n            }, this),\n            listaParcelas.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    width: \"400px\",\n                    margin: \"0 auto\",\n                    border: \"1px solid #ccc\",\n                    padding: \"10px\",\n                    borderRadius: 10\n                },\n                className: \"form form-group\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        children: \"Informe seu CPF\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                        lineNumber: 156,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"text\",\n                        className: \"form-control\",\n                        placeholder: \"000.000.000-00\",\n                        value: cpfFormatado,\n                        onChange: handleChangeCPF,\n                        ref: cpfLocatario,\n                        maxLength: 14\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                        lineNumber: 157,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        style: {\n                            marginTop: \"10px\",\n                            width: \"100%\"\n                        },\n                        className: \"btn btn-primary\",\n                        onClick: ()=>procurarParcelas(cpfFormatado),\n                        children: \"Procurar\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                        lineNumber: 158,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                lineNumber: 155,\n                columnNumber: 9\n            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    style: {\n                        margin: 10\n                    },\n                    onClick: ()=>{\n                        window.location.reload();\n                    },\n                    className: \"btn btn-primary\",\n                    children: \"Novo CPF\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                    lineNumber: 162,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                lineNumber: 161,\n                columnNumber: 9\n            }, this),\n            listaParcelas.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"table\", {\n                style: {\n                    width: \"95%\",\n                    margin: \"0 auto\",\n                    border: \"1px solid #ccc\",\n                    padding: \"10px\",\n                    borderRadius: 10\n                },\n                className: \"table table-striped\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"thead\", {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                    scope: \"col\",\n                                    children: \"Parcela\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                    lineNumber: 170,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                    scope: \"col\",\n                                    children: \"Vencimento\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                    lineNumber: 171,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                    scope: \"col\",\n                                    children: \"Valor\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                    lineNumber: 172,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                    scope: \"col\",\n                                    children: \"Status\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                    lineNumber: 173,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                    scope: \"col\",\n                                    children: \"PIX\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                    lineNumber: 174,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                            lineNumber: 169,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                        lineNumber: 168,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tbody\", {\n                        children: listaParcelas.map((value, index)=>{\n                            const venc = new Date(value.dataVencimento);\n                            const hoje = new Date();\n                            const atrasada = hoje > venc;\n                            const valorComJuros = atrasada ? calcularValorComMulta(parseFloat(value.valorAluguel), value.dataVencimento) : parseFloat(value.valorAluguel);\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                style: {\n                                    position: \"relative\"\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                        children: index + 1\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                        lineNumber: 187,\n                                        columnNumber: 19\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                        style: {\n                                            color: atrasada ? 'red' : 'inherit',\n                                            fontWeight: atrasada ? 'bold' : 'normal'\n                                        },\n                                        children: [\n                                            formatarData(value.dataVencimento),\n                                            \" \",\n                                            atrasada && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                style: {\n                                                    marginLeft: 10,\n                                                    fontWeight: 'bold'\n                                                },\n                                                children: \"(Atrasada)\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                                lineNumber: 189,\n                                                columnNumber: 71\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                        lineNumber: 188,\n                                        columnNumber: 19\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                        children: [\n                                            \"R$ \",\n                                            valorComJuros.toFixed(2)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                        lineNumber: 191,\n                                        columnNumber: 19\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                        children: value.quitada == \"N\" || value.quitada == 'n' ? \"Aberta\" : \"Quitada\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                        lineNumber: 192,\n                                        columnNumber: 19\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                        children: value.quitada == \"N\" || value.quitada == 'n' ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            className: \"btn btn-secondary\",\n                                            onClick: ()=>{\n                                                carregarDadosPix().then(()=>{\n                                                    setParcelaQRAtiva({\n                                                        ...value,\n                                                        index\n                                                    });\n                                                });\n                                            },\n                                            children: \"Gerar QR Code\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                            lineNumber: 196,\n                                            columnNumber: 25\n                                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            style: {\n                                                color: 'green',\n                                                fontWeight: 'bold'\n                                            },\n                                            children: \"Fatura Quitada\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                            lineNumber: 200,\n                                            columnNumber: 25\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                        lineNumber: 193,\n                                        columnNumber: 19\n                                    }, this)\n                                ]\n                            }, index, true, {\n                                fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                lineNumber: 186,\n                                columnNumber: 17\n                            }, this);\n                        })\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                        lineNumber: 177,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                lineNumber: 167,\n                columnNumber: 9\n            }, this),\n            parcelaQRAtiva && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                onClick: fecharModal,\n                style: {\n                    position: 'fixed',\n                    top: 0,\n                    left: 0,\n                    right: 0,\n                    bottom: 0,\n                    backgroundColor: 'rgba(0,0,0,0.5)',\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    zIndex: 9999\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    onClick: (e)=>e.stopPropagation(),\n                    style: {\n                        backgroundColor: '#fff',\n                        padding: 20,\n                        borderRadius: 8,\n                        boxShadow: '0 2px 10px rgba(0,0,0,0.3)',\n                        textAlign: 'center',\n                        minWidth: 280,\n                        position: 'relative'\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            children: [\n                                \"Parcela #\",\n                                parcelaQRAtiva.index + 1\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                            lineNumber: 235,\n                            columnNumber: 13\n                        }, this),\n                        (()=>{\n                            const valorCorrigido = calcularValorComMulta(parseFloat(parcelaQRAtiva.valorAluguel), parcelaQRAtiva.dataVencimento);\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(qrcode_react__WEBPACK_IMPORTED_MODULE_3__.QRCodeCanvas, {\n                                        value: gerarPayloadPix(valorCorrigido),\n                                        size: 200\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                        lineNumber: 242,\n                                        columnNumber: 19\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        style: {\n                                            marginTop: 10,\n                                            fontWeight: 'bold'\n                                        },\n                                        children: [\n                                            \"R$ \",\n                                            valorCorrigido.toFixed(2)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                                        lineNumber: 243,\n                                        columnNumber: 19\n                                    }, this)\n                                ]\n                            }, void 0, true);\n                        })(),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            onClick: fecharModal,\n                            style: {\n                                marginTop: 15,\n                                padding: '5px 10px',\n                                cursor: 'pointer'\n                            },\n                            children: \"Fechar\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                            lineNumber: 250,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                    lineNumber: 223,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n                lineNumber: 211,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\lucas\\\\OneDrive\\\\Documentos\\\\Projetos\\\\SGA\\\\frontend\\\\app\\\\page.js\",\n        lineNumber: 151,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"2l1nR7Y1a6vXWbNrL0hRbvNKGNE=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFNBQVM7d0JBQ1RDLGNBQWM7d0JBQ2Q0QyxXQUFXO3dCQUNYakQsV0FBVzt3QkFDWGtELFVBQVU7d0JBQ1ZuQixVQUFVO29CQUNaOztzQ0FFQSw4REFBQ29COztnQ0FBRztnQ0FBVTVILGVBQWVvRyxLQUFLLEdBQUc7Ozs7Ozs7d0JBR25DOzRCQUNBLE1BQU15QixpQkFBaUJsRSxzQkFBc0JuQixXQUFXeEMsZUFBZXVHLFlBQVksR0FBR3ZHLGVBQWVxRCxjQUFjOzRCQUNuSCxxQkFDRTs7a0RBQ0UsOERBQUM1RCxzREFBWUE7d0NBQUNrQixPQUFPcUIsZ0JBQWdCNkY7d0NBQWlCQyxNQUFNOzs7Ozs7a0RBQzVELDhEQUFDeEQ7d0NBQUlFLE9BQU87NENBQUVnQixXQUFXOzRDQUFJbUIsWUFBWTt3Q0FBTzs7NENBQUc7NENBQzdDa0IsZUFBZXBGLE9BQU8sQ0FBQzs7Ozs7Ozs7O3dCQUluQztzQ0FFQSw4REFBQzhDOzRCQUNDRSxTQUFTdEM7NEJBQ1RxQixPQUFPO2dDQUNMZ0IsV0FBVztnQ0FDWFgsU0FBUztnQ0FDVGtELFFBQVE7NEJBQ1Y7c0NBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU2I7R0FwUXdCckk7S0FBQUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbHVjYXNcXE9uZURyaXZlXFxEb2N1bWVudG9zXFxQcm9qZXRvc1xcU0dBXFxmcm9udGVuZFxcYXBwXFxwYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IGh0dHBDbGllbnQgZnJvbSBcIi4vdXRpbHMvaHR0cENsaWVudFwiO1xyXG5pbXBvcnQgeyBRUkNvZGVDYW52YXMgfSBmcm9tIFwicXJjb2RlLnJlYWN0XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lKCkge1xyXG4gIGNvbnN0IGNwZkxvY2F0YXJpbyA9IHVzZVJlZihudWxsKTtcclxuICBjb25zdCBbY3BmRm9ybWF0YWRvLCBzZXRDcGZGb3JtYXRhZG9dID0gdXNlU3RhdGUoXCJcIik7XHJcbiAgY29uc3QgW2xpc3RhUGFyY2VsYXMsIHNldExpc3RhUGFyY2VsYXNdID0gdXNlU3RhdGUoW10pO1xyXG4gIGNvbnN0IFtwYXJjZWxhUVJBdGl2YSwgc2V0UGFyY2VsYVFSQXRpdmFdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgY29uc3QgW2RhZG9zUGl4LCBzZXREYWRvc1BpeF0gPSB1c2VTdGF0ZShudWxsKTtcclxuXHJcbiAgZnVuY3Rpb24gZm9ybWF0YXJDUEYodmFsb3IpIHtcclxuICAgIHJldHVybiB2YWxvclxyXG4gICAgICAucmVwbGFjZSgvXFxEL2csIFwiXCIpIC8vIHJlbW92ZSBuw6NvIG7Dum1lcm9zXHJcbiAgICAgIC5zbGljZSgwLCAxMSkgLy8gbcOheGltbyAxMSBkw61naXRvc1xyXG4gICAgICAucmVwbGFjZSgvKFxcZHszfSkoXFxkKS8sIFwiJDEuJDJcIilcclxuICAgICAgLnJlcGxhY2UoLyhcXGR7M30pKFxcZCkvLCBcIiQxLiQyXCIpXHJcbiAgICAgIC5yZXBsYWNlKC8oXFxkezN9KShcXGR7MSwyfSkkLywgXCIkMS0kMlwiKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZUNQRihlKSB7XHJcbiAgICBzZXRDcGZGb3JtYXRhZG8oZm9ybWF0YXJDUEYoZS50YXJnZXQudmFsdWUpKTtcclxuICB9XHJcblxyXG4gIC8vIENhcnJlZ2FyIGRhZG9zIFBJWCBkbyBiYWNrZW5kXHJcbiAgZnVuY3Rpb24gY2FycmVnYXJEYWRvc1BpeCgpIHtcclxuICAgIHJldHVybiBodHRwQ2xpZW50LmdldCgnL3VzdWFyaW9zL2xpc3RhckNoYXZlJylcclxuICAgICAgLnRoZW4ociA9PiB7XHJcbiAgICAgICAgaWYgKHIuc3RhdHVzID09PSAyMDApIHJldHVybiByLmpzb24oKTtcclxuICAgICAgICBhbGVydCgnRXJybyBhbyBsaXN0YXIgY2hhdmVzLicpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9KVxyXG4gICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHNldERhZG9zUGl4KGRhdGFbMF0pO1xyXG4gICAgICAgICAgcmV0dXJuIGRhdGFbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHByb2N1cmFyUGFyY2VsYXMoY3BmRm9ybWF0YWRvKSB7XHJcbiAgICBjb25zdCBjcGZMaW1wbyA9IGNwZkZvcm1hdGFkby5yZXBsYWNlKC9cXEQvZywgXCJcIik7IC8vIHJlbW92ZSBwb250b3MgZSB0cmHDp29cclxuICAgIGh0dHBDbGllbnQuZ2V0KGAvYWx1Z3VlbC9vYnRlckFsdWd1ZWlzLyR7Y3BmTGltcG99YClcclxuICAgICAgLnRoZW4ociA9PiB7XHJcbiAgICAgICAgaWYgKHIuc3RhdHVzID09PSAyMDApIHtcclxuICAgICAgICAgIHJldHVybiByLmpzb24oKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWxlcnQoJ0Vycm8gYW8gbGlzdGFyIHBhcmNlbGFzLicpO1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGFsZXJ0KCdOZW5odW1hIHBhcmNlbGEgZW5jb250cmFkYS4nKTtcclxuICAgICAgICAgIHNldExpc3RhUGFyY2VsYXMoW10pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzZXRMaXN0YVBhcmNlbGFzKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNhcnJlZ2FyRGFkb3NQaXgoKTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8vIENhbGN1bGEgQ1JDMTYgQ0NJVFQtRkFMU0UgKHBhZHLDo28gUElYKVxyXG4gIGZ1bmN0aW9uIGNhbGN1bGFyQ1JDMTYoc3RyKSB7XHJcbiAgICBsZXQgY3JjID0gMHhGRkZGO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY3JjIF49IHN0ci5jaGFyQ29kZUF0KGkpIDw8IDg7XHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgODsgaisrKSB7XHJcbiAgICAgICAgaWYgKChjcmMgJiAweDgwMDApICE9PSAwKSB7XHJcbiAgICAgICAgICBjcmMgPSAoKGNyYyA8PCAxKSBeIDB4MTAyMSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNyYyA8PD0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3JjICY9IDB4RkZGRjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCg0LCAnMCcpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2VyYXJQYXlsb2FkUGl4KFxyXG4gICAgdmFsb3IsXHJcbiAgICBjaGF2ZVBpeCA9IGRhZG9zUGl4Py5jaGF2ZVBpeCA/IChkYWRvc1BpeC5jaGF2ZVBpeC5zdGFydHNXaXRoKCcrJykgPyBkYWRvc1BpeC5jaGF2ZVBpeCA6ICcrNTUnICsgZGFkb3NQaXguY2hhdmVQaXgpIDogXCIrNTUxODk5NjU3MDA0MlwiLFxyXG4gICAgbm9tZVJlY2ViZWRvciA9IGRhZG9zUGl4Py5ub21lUGl4IHx8IFwiTFVDQVMgR09JU1wiXHJcbiAgKSB7XHJcbiAgICBjb25zb2xlLmxvZyhjaGF2ZVBpeCwgbm9tZVJlY2ViZWRvcik7XHJcbiAgICBjb25zdCB2YWxvckZvcm1hdGFkbyA9IHBhcnNlRmxvYXQodmFsb3IpLnRvRml4ZWQoMik7XHJcbiAgICBjb25zdCBjaWRhZGUgPSBcIlBSRVMgUFJVREVOVEVcIjtcclxuICAgIGNvbnN0IG5vbWUgPSBub21lUmVjZWJlZG9yLnN1YnN0cmluZygwLCAyNSkudG9VcHBlckNhc2UoKTtcclxuICAgIGNvbnN0IGNpZGFkZUxpbWl0ZSA9IGNpZGFkZS5zdWJzdHJpbmcoMCwgMTUpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICBjb25zdCBndWkgPSBcIkJSLkdPVi5CQ0IuUElYXCI7XHJcbiAgICBjb25zdCBpbmZvQWRpY2lvbmFsID0gXCIqKipcIjtcclxuXHJcbiAgICBjb25zdCBtZXJjaGFudEFjY291bnRJbmZvID1cclxuICAgICAgXCIwMFwiICsgZ3VpLmxlbmd0aC50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJykgKyBndWkgK1xyXG4gICAgICBcIjAxXCIgKyBjaGF2ZVBpeC5sZW5ndGgudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpICsgY2hhdmVQaXg7XHJcblxyXG4gICAgY29uc3QgY2FtcG8yNiA9IFwiMjZcIiArIG1lcmNoYW50QWNjb3VudEluZm8ubGVuZ3RoLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKSArIG1lcmNoYW50QWNjb3VudEluZm87XHJcblxyXG4gICAgY29uc3QgcGF5bG9hZFNlbUNSQyA9XHJcbiAgICAgIFwiMDAwMjAxXCIgK1xyXG4gICAgICBjYW1wbzI2ICtcclxuICAgICAgXCI1MjA0MDAwMFwiICtcclxuICAgICAgXCI1MzAzOTg2XCIgK1xyXG4gICAgICBcIjU0XCIgKyB2YWxvckZvcm1hdGFkby5sZW5ndGgudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpICsgdmFsb3JGb3JtYXRhZG8gK1xyXG4gICAgICBcIjU4MDJCUlwiICtcclxuICAgICAgXCI1OVwiICsgbm9tZS5sZW5ndGgudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpICsgbm9tZSArXHJcbiAgICAgIFwiNjBcIiArIGNpZGFkZUxpbWl0ZS5sZW5ndGgudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpICsgY2lkYWRlTGltaXRlICtcclxuICAgICAgXCI2MlwiICsgXCIwN1wiICtcclxuICAgICAgXCIwNVwiICsgaW5mb0FkaWNpb25hbC5sZW5ndGgudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpICsgaW5mb0FkaWNpb25hbCArXHJcbiAgICAgIFwiNjMwNFwiO1xyXG5cclxuICAgIGNvbnN0IGNyYyA9IGNhbGN1bGFyQ1JDMTYocGF5bG9hZFNlbUNSQyk7XHJcbiAgICByZXR1cm4gcGF5bG9hZFNlbUNSQyArIGNyYztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZlY2hhck1vZGFsKCkge1xyXG4gICAgc2V0UGFyY2VsYVFSQXRpdmEobnVsbCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmb3JtYXRhckRhdGEoZGF0YVZlbmNpbWVudG8pIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRhVmVuY2ltZW50bylcclxuICAgICAgLnRvTG9jYWxlRGF0ZVN0cmluZygncHQtQlInLCB7IGRheTogJzItZGlnaXQnLCBtb250aDogJzItZGlnaXQnLCB5ZWFyOiAnbnVtZXJpYycgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBDYWxjdWxhIHZhbG9yIGNvbSBtdWx0YSBkZSAyJSBhbyBtw6pzIGUganVyb3MgZGUgMSUgYW8gZGlhIHBhcmEgcGFyY2VsYXMgYXRyYXNhZGFzXHJcbiAgZnVuY3Rpb24gY2FsY3VsYXJWYWxvckNvbU11bHRhKHZhbG9yT3JpZ2luYWwsIGRhdGFWZW5jaW1lbnRvKSB7XHJcbiAgICBjb25zdCBob2plID0gbmV3IERhdGUoKTtcclxuICAgIGNvbnN0IHZlbmMgPSBuZXcgRGF0ZShkYXRhVmVuY2ltZW50byk7XHJcbiAgICBpZiAoaG9qZSA8PSB2ZW5jKSByZXR1cm4gcGFyc2VGbG9hdCh2YWxvck9yaWdpbmFsKTtcclxuXHJcbiAgICBjb25zdCBkaWZmVGltZSA9IGhvamUgLSB2ZW5jO1xyXG4gICAgY29uc3QgZGlmZkRpYXMgPSBNYXRoLmZsb29yKGRpZmZUaW1lIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKTtcclxuXHJcbiAgICAvLyBNdWx0YSBkZSAyJSBhbyBtw6pzID0gMiUgLyAzMCBkaWFzIHBvciBkaWEgYXRyYXNhZG9cclxuICAgIGNvbnN0IG11bHRhRGlhcmlhID0gMC4wMiAvIDMwO1xyXG4gICAgY29uc3QgbXVsdGEgPSB2YWxvck9yaWdpbmFsICogbXVsdGFEaWFyaWEgKiBkaWZmRGlhcztcclxuXHJcbiAgICAvLyBKdXJvcyBkZSAxJSBwb3IgZGlhXHJcbiAgICBjb25zdCBqdXJvcyA9IHZhbG9yT3JpZ2luYWwgKiAwLjAxICogZGlmZkRpYXM7XHJcblxyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsb3JPcmlnaW5hbCkgKyBtdWx0YSArIGp1cm9zO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXY+XHJcbiAgICAgIDxoMSBzdHlsZT17eyB0ZXh0QWxpZ246IFwiY2VudGVyXCIgfX0+VmVyaWZpY2FyIGFzIHBhcmNlbGFzIHBlbG8gQ1BGPC9oMT5cclxuXHJcbiAgICAgIHtsaXN0YVBhcmNlbGFzLmxlbmd0aCA9PT0gMCA/IChcclxuICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiBcIjQwMHB4XCIsIG1hcmdpbjogXCIwIGF1dG9cIiwgYm9yZGVyOiBcIjFweCBzb2xpZCAjY2NjXCIsIHBhZGRpbmc6IFwiMTBweFwiLCBib3JkZXJSYWRpdXM6IDEwIH19IGNsYXNzTmFtZT1cImZvcm0gZm9ybS1ncm91cFwiPlxyXG4gICAgICAgICAgPGxhYmVsPkluZm9ybWUgc2V1IENQRjwvbGFiZWw+XHJcbiAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIiBwbGFjZWhvbGRlcj1cIjAwMC4wMDAuMDAwLTAwXCIgdmFsdWU9e2NwZkZvcm1hdGFkb30gb25DaGFuZ2U9e2hhbmRsZUNoYW5nZUNQRn0gcmVmPXtjcGZMb2NhdGFyaW99IG1heExlbmd0aD17MTR9IC8+XHJcbiAgICAgICAgICA8YnV0dG9uIHN0eWxlPXt7IG1hcmdpblRvcDogXCIxMHB4XCIsIHdpZHRoOiBcIjEwMCVcIiB9fSBjbGFzc05hbWU9XCJidG4gYnRuLXByaW1hcnlcIiBvbkNsaWNrPXsoKSA9PiBwcm9jdXJhclBhcmNlbGFzKGNwZkZvcm1hdGFkbyl9PlByb2N1cmFyPC9idXR0b24+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICkgOiAoXHJcbiAgICAgICAgPGRpdj5cclxuICAgICAgICAgIDxidXR0b24gc3R5bGU9e3sgbWFyZ2luOiAxMCB9fSBvbkNsaWNrPXsoKSA9PiB7IHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKSB9fSBjbGFzc05hbWU9XCJidG4gYnRuLXByaW1hcnlcIj5Ob3ZvIENQRjwvYnV0dG9uPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICApfVxyXG5cclxuICAgICAge2xpc3RhUGFyY2VsYXMubGVuZ3RoID4gMCAmJiAoXHJcbiAgICAgICAgPHRhYmxlIHN0eWxlPXt7IHdpZHRoOiBcIjk1JVwiLCBtYXJnaW46IFwiMCBhdXRvXCIsIGJvcmRlcjogXCIxcHggc29saWQgI2NjY1wiLCBwYWRkaW5nOiBcIjEwcHhcIiwgYm9yZGVyUmFkaXVzOiAxMCB9fSBjbGFzc05hbWU9XCJ0YWJsZSB0YWJsZS1zdHJpcGVkXCI+XHJcbiAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICA8dGggc2NvcGU9XCJjb2xcIj5QYXJjZWxhPC90aD5cclxuICAgICAgICAgICAgICA8dGggc2NvcGU9XCJjb2xcIj5WZW5jaW1lbnRvPC90aD5cclxuICAgICAgICAgICAgICA8dGggc2NvcGU9XCJjb2xcIj5WYWxvcjwvdGg+XHJcbiAgICAgICAgICAgICAgPHRoIHNjb3BlPVwiY29sXCI+U3RhdHVzPC90aD5cclxuICAgICAgICAgICAgICA8dGggc2NvcGU9XCJjb2xcIj5QSVg8L3RoPlxyXG4gICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgPC90aGVhZD5cclxuICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAge2xpc3RhUGFyY2VsYXMubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCB2ZW5jID0gbmV3IERhdGUodmFsdWUuZGF0YVZlbmNpbWVudG8pO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGhvamUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGF0cmFzYWRhID0gaG9qZSA+IHZlbmM7XHJcblxyXG4gICAgICAgICAgICAgIGNvbnN0IHZhbG9yQ29tSnVyb3MgPSBhdHJhc2FkYSA/IGNhbGN1bGFyVmFsb3JDb21NdWx0YShwYXJzZUZsb2F0KHZhbHVlLnZhbG9yQWx1Z3VlbCksIHZhbHVlLmRhdGFWZW5jaW1lbnRvKSA6IHBhcnNlRmxvYXQodmFsdWUudmFsb3JBbHVndWVsKTtcclxuXHJcbiAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgIDx0ciBrZXk9e2luZGV4fSBzdHlsZT17eyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH19PlxyXG4gICAgICAgICAgICAgICAgICA8dGQ+e2luZGV4ICsgMX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICA8dGQgc3R5bGU9e3sgY29sb3I6IGF0cmFzYWRhID8gJ3JlZCcgOiAnaW5oZXJpdCcsIGZvbnRXZWlnaHQ6IGF0cmFzYWRhID8gJ2JvbGQnIDogJ25vcm1hbCcgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAge2Zvcm1hdGFyRGF0YSh2YWx1ZS5kYXRhVmVuY2ltZW50byl9IHthdHJhc2FkYSAmJiA8c3BhbiBzdHlsZT17eyBtYXJnaW5MZWZ0OiAxMCwgZm9udFdlaWdodDogJ2JvbGQnIH19PihBdHJhc2FkYSk8L3NwYW4+fVxyXG4gICAgICAgICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICAgICAgICA8dGQ+UiQge3ZhbG9yQ29tSnVyb3MudG9GaXhlZCgyKX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICA8dGQ+e3ZhbHVlLnF1aXRhZGEgPT0gXCJOXCIgfHwgdmFsdWUucXVpdGFkYSA9PSAnbicgPyBcIkFiZXJ0YVwiIDogXCJRdWl0YWRhXCJ9PC90ZD5cclxuICAgICAgICAgICAgICAgICAgPHRkPlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnF1aXRhZGEgPT0gXCJOXCIgfHwgdmFsdWUucXVpdGFkYSA9PSAnbicgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJ0biBidG4tc2Vjb25kYXJ5XCIgb25DbGljaz17KCkgPT4geyBjYXJyZWdhckRhZG9zUGl4KCkudGhlbigoKSA9PiB7IHNldFBhcmNlbGFRUkF0aXZhKHsgLi4udmFsdWUsIGluZGV4IH0pOyB9KTsgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgR2VyYXIgUVIgQ29kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBzdHlsZT17eyBjb2xvcjogJ2dyZWVuJywgZm9udFdlaWdodDogJ2JvbGQnIH19PkZhdHVyYSBRdWl0YWRhPC9wPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICB9KX1cclxuICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgPC90YWJsZT5cclxuICAgICAgKX1cclxuXHJcbiAgICAgIHtwYXJjZWxhUVJBdGl2YSAmJiAoXHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgb25DbGljaz17ZmVjaGFyTW9kYWx9XHJcbiAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcclxuICAgICAgICAgICAgdG9wOiAwLCBsZWZ0OiAwLCByaWdodDogMCwgYm90dG9tOiAwLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuNSknLFxyXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXHJcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcclxuICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgIHpJbmRleDogOTk5OSxcclxuICAgICAgICAgIH19XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICBvbkNsaWNrPXtlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCl9XHJcbiAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2ZmZicsXHJcbiAgICAgICAgICAgICAgcGFkZGluZzogMjAsXHJcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiA4LFxyXG4gICAgICAgICAgICAgIGJveFNoYWRvdzogJzAgMnB4IDEwcHggcmdiYSgwLDAsMCwwLjMpJyxcclxuICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxyXG4gICAgICAgICAgICAgIG1pbldpZHRoOiAyODAsXHJcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIDxoMz5QYXJjZWxhICN7cGFyY2VsYVFSQXRpdmEuaW5kZXggKyAxfTwvaDM+XHJcblxyXG4gICAgICAgICAgICB7LyogQ2FsY3VsYXIgdmFsb3IgY29tIG11bHRhIGUganVyb3MgKi99XHJcbiAgICAgICAgICAgIHsoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHZhbG9yQ29ycmlnaWRvID0gY2FsY3VsYXJWYWxvckNvbU11bHRhKHBhcnNlRmxvYXQocGFyY2VsYVFSQXRpdmEudmFsb3JBbHVndWVsKSwgcGFyY2VsYVFSQXRpdmEuZGF0YVZlbmNpbWVudG8pO1xyXG4gICAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICA8PlxyXG4gICAgICAgICAgICAgICAgICA8UVJDb2RlQ2FudmFzIHZhbHVlPXtnZXJhclBheWxvYWRQaXgodmFsb3JDb3JyaWdpZG8pfSBzaXplPXsyMDB9IC8+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgbWFyZ2luVG9wOiAxMCwgZm9udFdlaWdodDogJ2JvbGQnIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIFIkIHt2YWxvckNvcnJpZ2lkby50b0ZpeGVkKDIpfVxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvPlxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0pKCl9XHJcblxyXG4gICAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgICAgb25DbGljaz17ZmVjaGFyTW9kYWx9XHJcbiAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMTUsXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnNXB4IDEwcHgnLFxyXG4gICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXHJcbiAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIEZlY2hhclxyXG4gICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICApfVxyXG5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiaHR0cENsaWVudCIsIlFSQ29kZUNhbnZhcyIsIkhvbWUiLCJjcGZMb2NhdGFyaW8iLCJjcGZGb3JtYXRhZG8iLCJzZXRDcGZGb3JtYXRhZG8iLCJsaXN0YVBhcmNlbGFzIiwic2V0TGlzdGFQYXJjZWxhcyIsInBhcmNlbGFRUkF0aXZhIiwic2V0UGFyY2VsYVFSQXRpdmEiLCJkYWRvc1BpeCIsInNldERhZG9zUGl4IiwiZm9ybWF0YXJDUEYiLCJ2YWxvciIsInJlcGxhY2UiLCJzbGljZSIsImhhbmRsZUNoYW5nZUNQRiIsImUiLCJ0YXJnZXQiLCJ2YWx1ZSIsImNhcnJlZ2FyRGFkb3NQaXgiLCJnZXQiLCJ0aGVuIiwiciIsInN0YXR1cyIsImpzb24iLCJhbGVydCIsImRhdGEiLCJsZW5ndGgiLCJwcm9jdXJhclBhcmNlbGFzIiwiY3BmTGltcG8iLCJjYWxjdWxhckNSQzE2Iiwic3RyIiwiY3JjIiwiaSIsImNoYXJDb2RlQXQiLCJqIiwidG9TdHJpbmciLCJ0b1VwcGVyQ2FzZSIsInBhZFN0YXJ0IiwiZ2VyYXJQYXlsb2FkUGl4IiwiY2hhdmVQaXgiLCJzdGFydHNXaXRoIiwibm9tZVJlY2ViZWRvciIsIm5vbWVQaXgiLCJjb25zb2xlIiwibG9nIiwidmFsb3JGb3JtYXRhZG8iLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsImNpZGFkZSIsIm5vbWUiLCJzdWJzdHJpbmciLCJjaWRhZGVMaW1pdGUiLCJndWkiLCJpbmZvQWRpY2lvbmFsIiwibWVyY2hhbnRBY2NvdW50SW5mbyIsImNhbXBvMjYiLCJwYXlsb2FkU2VtQ1JDIiwiZmVjaGFyTW9kYWwiLCJmb3JtYXRhckRhdGEiLCJkYXRhVmVuY2ltZW50byIsIkRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJkYXkiLCJtb250aCIsInllYXIiLCJjYWxjdWxhclZhbG9yQ29tTXVsdGEiLCJ2YWxvck9yaWdpbmFsIiwiaG9qZSIsInZlbmMiLCJkaWZmVGltZSIsImRpZmZEaWFzIiwiTWF0aCIsImZsb29yIiwibXVsdGFEaWFyaWEiLCJtdWx0YSIsImp1cm9zIiwiZGl2IiwiaDEiLCJzdHlsZSIsInRleHRBbGlnbiIsIndpZHRoIiwibWFyZ2luIiwiYm9yZGVyIiwicGFkZGluZyIsImJvcmRlclJhZGl1cyIsImNsYXNzTmFtZSIsImxhYmVsIiwiaW5wdXQiLCJ0eXBlIiwicGxhY2Vob2xkZXIiLCJvbkNoYW5nZSIsInJlZiIsIm1heExlbmd0aCIsImJ1dHRvbiIsIm1hcmdpblRvcCIsIm9uQ2xpY2siLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInJlbG9hZCIsInRhYmxlIiwidGhlYWQiLCJ0ciIsInRoIiwic2NvcGUiLCJ0Ym9keSIsIm1hcCIsImluZGV4IiwiYXRyYXNhZGEiLCJ2YWxvckNvbUp1cm9zIiwidmFsb3JBbHVndWVsIiwicG9zaXRpb24iLCJ0ZCIsImNvbG9yIiwiZm9udFdlaWdodCIsInNwYW4iLCJtYXJnaW5MZWZ0IiwicXVpdGFkYSIsInAiLCJ0b3AiLCJsZWZ0IiwicmlnaHQiLCJib3R0b20iLCJiYWNrZ3JvdW5kQ29sb3IiLCJkaXNwbGF5IiwianVzdGlmeUNvbnRlbnQiLCJhbGlnbkl0ZW1zIiwiekluZGV4Iiwic3RvcFByb3BhZ2F0aW9uIiwiYm94U2hhZG93IiwibWluV2lkdGgiLCJoMyIsInZhbG9yQ29ycmlnaWRvIiwic2l6ZSIsImN1cnNvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/utils/httpClient.js":
/*!*********************************!*\
  !*** ./app/utils/httpClient.js ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cookie */ \"(app-pages-browser)/./node_modules/cookie/dist/index.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nconst baseUrl = \"http://localhost:4000\";\nlet chaveApi = \"\";\nif (typeof document !== 'undefined') {\n    let cookies = (0,cookie__WEBPACK_IMPORTED_MODULE_0__.parse)(document.cookie);\n    if (cookies.cookieAuth !== undefined) {\n        chaveApi = cookies.cookieAuth;\n    }\n}\nconst httpClient = {\n    get: (endpoint)=>{\n        let config = {\n            credentials: 'include',\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n                'chaveapi': chaveApi\n            }\n        };\n        endpoint = baseUrl + endpoint;\n        return fetch(endpoint, config);\n    },\n    post: (endpoint, body)=>{\n        let config = {\n            credentials: 'include',\n            method: \"POST\",\n            headers: {\n                'Content-Type': 'application/json',\n                'chaveapi': chaveApi\n            },\n            body: JSON.stringify(body)\n        };\n        endpoint = baseUrl + endpoint;\n        return fetch(endpoint, config);\n    },\n    delete: (endpoint)=>{\n        let config = {\n            credentials: 'include',\n            method: \"DELETE\",\n            headers: {\n                'Content-Type': 'application/json',\n                'chaveapi': chaveApi\n            }\n        };\n        endpoint = baseUrl + endpoint;\n        return fetch(endpoint, config);\n    },\n    put: (endpoint, body)=>{\n        let config = {\n            credentials: 'include',\n            method: \"PUT\",\n            headers: {\n                'Content-Type': 'application/json',\n                'chaveapi': chaveApi\n            },\n            body: JSON.stringify(body)\n        };\n        endpoint = baseUrl + endpoint;\n        return fetch(endpoint, config);\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (httpClient);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy9odHRwQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7OzZEQUM2QjtBQUU3QixNQUFNQyxVQUFVO0FBRWhCLElBQUlDLFdBQVc7QUFDZixJQUFJLE9BQU9DLGFBQWEsYUFBYTtJQUNqQyxJQUFJQyxVQUFVSiw2Q0FBS0EsQ0FBQ0csU0FBU0UsTUFBTTtJQUNuQyxJQUFJRCxRQUFRRSxVQUFVLEtBQUtDLFdBQVc7UUFDbENMLFdBQVdFLFFBQVFFLFVBQVU7SUFDakM7QUFDSjtBQUVBLE1BQU1FLGFBQWE7SUFDZkMsS0FBSyxDQUFDQztRQUNGLElBQUlDLFNBQVM7WUFDVEMsYUFBYTtZQUNiQyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ0wsZ0JBQWdCO2dCQUNoQixZQUFZWjtZQUNoQjtRQUNKO1FBRUFRLFdBQVdULFVBQVVTO1FBQ3JCLE9BQU9LLE1BQU1MLFVBQVVDO0lBQzNCO0lBQ0FLLE1BQU0sQ0FBQ04sVUFBVU87UUFDYixJQUFJTixTQUFTO1lBQ1RDLGFBQWE7WUFDYkMsUUFBUTtZQUNSQyxTQUFTO2dCQUNMLGdCQUFnQjtnQkFDaEIsWUFBWVo7WUFDaEI7WUFDQWUsTUFBTUMsS0FBS0MsU0FBUyxDQUFDRjtRQUN6QjtRQUVBUCxXQUFXVCxVQUFVUztRQUNyQixPQUFPSyxNQUFNTCxVQUFVQztJQUMzQjtJQUNBUyxRQUFRLENBQUNWO1FBQ0wsSUFBSUMsU0FBUztZQUNUQyxhQUFhO1lBQ2JDLFFBQVE7WUFDUkMsU0FBUztnQkFDTCxnQkFBZ0I7Z0JBQ2hCLFlBQVlaO1lBQ2hCO1FBQ0o7UUFFQVEsV0FBV1QsVUFBVVM7UUFDckIsT0FBT0ssTUFBTUwsVUFBVUM7SUFDM0I7SUFDQVUsS0FBSyxDQUFDWCxVQUFVTztRQUNaLElBQUlOLFNBQVM7WUFDVEMsYUFBYTtZQUNiQyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ0wsZ0JBQWdCO2dCQUNoQixZQUFZWjtZQUNoQjtZQUNBZSxNQUFNQyxLQUFLQyxTQUFTLENBQUNGO1FBQ3pCO1FBQ0FQLFdBQVdULFVBQVVTO1FBQ3JCLE9BQU9LLE1BQU1MLFVBQVVDO0lBQzNCO0FBQ0o7QUFFQSxpRUFBZUgsVUFBVUEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsdWNhc1xcT25lRHJpdmVcXERvY3VtZW50b3NcXFByb2pldG9zXFxTR0FcXGZyb250ZW5kXFxhcHBcXHV0aWxzXFxodHRwQ2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5pbXBvcnQge3BhcnNlfSBmcm9tICdjb29raWUnO1xyXG5cclxuY29uc3QgYmFzZVVybCA9IFwiaHR0cDovL2xvY2FsaG9zdDo0MDAwXCI7XHJcblxyXG5sZXQgY2hhdmVBcGkgPSBcIlwiO1xyXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgbGV0IGNvb2tpZXMgPSBwYXJzZShkb2N1bWVudC5jb29raWUpO1xyXG4gICAgaWYgKGNvb2tpZXMuY29va2llQXV0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY2hhdmVBcGkgPSBjb29raWVzLmNvb2tpZUF1dGg7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IGh0dHBDbGllbnQgPSB7XHJcbiAgICBnZXQ6IChlbmRwb2ludCkgPT4ge1xyXG4gICAgICAgIGxldCBjb25maWcgPSB7XHJcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgICAgICAnY2hhdmVhcGknOiBjaGF2ZUFwaVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbmRwb2ludCA9IGJhc2VVcmwgKyBlbmRwb2ludDtcclxuICAgICAgICByZXR1cm4gZmV0Y2goZW5kcG9pbnQsIGNvbmZpZyk7XHJcbiAgICB9LFxyXG4gICAgcG9zdDogKGVuZHBvaW50LCBib2R5KSA9PiB7XHJcbiAgICAgICAgbGV0IGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgICAgICdjaGF2ZWFwaSc6IGNoYXZlQXBpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbmRwb2ludCA9IGJhc2VVcmwgKyBlbmRwb2ludDtcclxuICAgICAgICByZXR1cm4gZmV0Y2goZW5kcG9pbnQsIGNvbmZpZyk7XHJcbiAgICB9LFxyXG4gICAgZGVsZXRlOiAoZW5kcG9pbnQpID0+IHtcclxuICAgICAgICBsZXQgY29uZmlnID0ge1xyXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxyXG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgICAgICAnY2hhdmVhcGknOiBjaGF2ZUFwaVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbmRwb2ludCA9IGJhc2VVcmwgKyBlbmRwb2ludDtcclxuICAgICAgICByZXR1cm4gZmV0Y2goZW5kcG9pbnQsIGNvbmZpZyk7XHJcbiAgICB9LFxyXG4gICAgcHV0OiAoZW5kcG9pbnQsIGJvZHkpID0+IHtcclxuICAgICAgICBsZXQgY29uZmlnID0ge1xyXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxyXG4gICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgICAgICAnY2hhdmVhcGknOiBjaGF2ZUFwaVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbmRwb2ludCA9IGJhc2VVcmwgKyBlbmRwb2ludDtcclxuICAgICAgICByZXR1cm4gZmV0Y2goZW5kcG9pbnQsIGNvbmZpZylcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgaHR0cENsaWVudDtcclxuIl0sIm5hbWVzIjpbInBhcnNlIiwiYmFzZVVybCIsImNoYXZlQXBpIiwiZG9jdW1lbnQiLCJjb29raWVzIiwiY29va2llIiwiY29va2llQXV0aCIsInVuZGVmaW5lZCIsImh0dHBDbGllbnQiLCJnZXQiLCJlbmRwb2ludCIsImNvbmZpZyIsImNyZWRlbnRpYWxzIiwibWV0aG9kIiwiaGVhZGVycyIsImZldGNoIiwicG9zdCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVsZXRlIiwicHV0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/httpClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/cookie/dist/index.js":
/*!*******************************************!*\
  !*** ./node_modules/cookie/dist/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parse = parse;\nexports.serialize = serialize;\n/**\n * RegExp to match cookie-name in RFC 6265 sec 4.1.1\n * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\n * which has been replaced by the token definition in RFC 7230 appendix B.\n *\n * cookie-name       = token\n * token             = 1*tchar\n * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\n *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\n *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n *\n * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191\n * Allow same range as cookie value, except `=`, which delimits end of name.\n */\nconst cookieNameRegExp = /^[\\u0021-\\u003A\\u003C\\u003E-\\u007E]+$/;\n/**\n * RegExp to match cookie-value in RFC 6265 sec 4.1.1\n *\n * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n *                     ; US-ASCII characters excluding CTLs,\n *                     ; whitespace DQUOTE, comma, semicolon,\n *                     ; and backslash\n *\n * Allowing more characters: https://github.com/jshttp/cookie/issues/191\n * Comma, backslash, and DQUOTE are not part of the parsing algorithm.\n */\nconst cookieValueRegExp = /^[\\u0021-\\u003A\\u003C-\\u007E]*$/;\n/**\n * RegExp to match domain-value in RFC 6265 sec 4.1.1\n *\n * domain-value      = <subdomain>\n *                     ; defined in [RFC1034], Section 3.5, as\n *                     ; enhanced by [RFC1123], Section 2.1\n * <subdomain>       = <label> | <subdomain> \".\" <label>\n * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\n *                     Labels must be 63 characters or less.\n *                     'let-dig' not 'letter' in the first char, per RFC1123\n * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\n * <let-dig-hyp>     = <let-dig> | \"-\"\n * <let-dig>         = <letter> | <digit>\n * <letter>          = any one of the 52 alphabetic characters A through Z in\n *                     upper case and a through z in lower case\n * <digit>           = any one of the ten digits 0 through 9\n *\n * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\n *\n * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\n * character is not permitted, but a trailing %x2E (\".\"), if present, will\n * cause the user agent to ignore the attribute.)\n */\nconst domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n/**\n * RegExp to match path-value in RFC 6265 sec 4.1.1\n *\n * path-value        = <any CHAR except CTLs or \";\">\n * CHAR              = %x01-7F\n *                     ; defined in RFC 5234 appendix B.1\n */\nconst pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\nconst __toString = Object.prototype.toString;\nconst NullObject = /* @__PURE__ */ (() => {\n    const C = function () { };\n    C.prototype = Object.create(null);\n    return C;\n})();\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nfunction parse(str, options) {\n    const obj = new NullObject();\n    const len = str.length;\n    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\n    if (len < 2)\n        return obj;\n    const dec = options?.decode || decode;\n    let index = 0;\n    do {\n        const eqIdx = str.indexOf(\"=\", index);\n        if (eqIdx === -1)\n            break; // No more cookie pairs.\n        const colonIdx = str.indexOf(\";\", index);\n        const endIdx = colonIdx === -1 ? len : colonIdx;\n        if (eqIdx > endIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n            continue;\n        }\n        const keyStartIdx = startIndex(str, index, eqIdx);\n        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\n        const key = str.slice(keyStartIdx, keyEndIdx);\n        // only assign once\n        if (obj[key] === undefined) {\n            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);\n            let valEndIdx = endIndex(str, endIdx, valStartIdx);\n            const value = dec(str.slice(valStartIdx, valEndIdx));\n            obj[key] = value;\n        }\n        index = endIdx + 1;\n    } while (index < len);\n    return obj;\n}\nfunction startIndex(str, index, max) {\n    do {\n        const code = str.charCodeAt(index);\n        if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */)\n            return index;\n    } while (++index < max);\n    return max;\n}\nfunction endIndex(str, index, min) {\n    while (index > min) {\n        const code = str.charCodeAt(--index);\n        if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */)\n            return index + 1;\n    }\n    return min;\n}\n/**\n * Serialize data into a cookie header.\n *\n * Serialize a name value pair into a cookie string suitable for\n * http headers. An optional options object specifies cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n */\nfunction serialize(name, val, options) {\n    const enc = options?.encode || encodeURIComponent;\n    if (!cookieNameRegExp.test(name)) {\n        throw new TypeError(`argument name is invalid: ${name}`);\n    }\n    const value = enc(val);\n    if (!cookieValueRegExp.test(value)) {\n        throw new TypeError(`argument val is invalid: ${val}`);\n    }\n    let str = name + \"=\" + value;\n    if (!options)\n        return str;\n    if (options.maxAge !== undefined) {\n        if (!Number.isInteger(options.maxAge)) {\n            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);\n        }\n        str += \"; Max-Age=\" + options.maxAge;\n    }\n    if (options.domain) {\n        if (!domainValueRegExp.test(options.domain)) {\n            throw new TypeError(`option domain is invalid: ${options.domain}`);\n        }\n        str += \"; Domain=\" + options.domain;\n    }\n    if (options.path) {\n        if (!pathValueRegExp.test(options.path)) {\n            throw new TypeError(`option path is invalid: ${options.path}`);\n        }\n        str += \"; Path=\" + options.path;\n    }\n    if (options.expires) {\n        if (!isDate(options.expires) ||\n            !Number.isFinite(options.expires.valueOf())) {\n            throw new TypeError(`option expires is invalid: ${options.expires}`);\n        }\n        str += \"; Expires=\" + options.expires.toUTCString();\n    }\n    if (options.httpOnly) {\n        str += \"; HttpOnly\";\n    }\n    if (options.secure) {\n        str += \"; Secure\";\n    }\n    if (options.partitioned) {\n        str += \"; Partitioned\";\n    }\n    if (options.priority) {\n        const priority = typeof options.priority === \"string\"\n            ? options.priority.toLowerCase()\n            : undefined;\n        switch (priority) {\n            case \"low\":\n                str += \"; Priority=Low\";\n                break;\n            case \"medium\":\n                str += \"; Priority=Medium\";\n                break;\n            case \"high\":\n                str += \"; Priority=High\";\n                break;\n            default:\n                throw new TypeError(`option priority is invalid: ${options.priority}`);\n        }\n    }\n    if (options.sameSite) {\n        const sameSite = typeof options.sameSite === \"string\"\n            ? options.sameSite.toLowerCase()\n            : options.sameSite;\n        switch (sameSite) {\n            case true:\n            case \"strict\":\n                str += \"; SameSite=Strict\";\n                break;\n            case \"lax\":\n                str += \"; SameSite=Lax\";\n                break;\n            case \"none\":\n                str += \"; SameSite=None\";\n                break;\n            default:\n                throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);\n        }\n    }\n    return str;\n}\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n */\nfunction decode(str) {\n    if (str.indexOf(\"%\") === -1)\n        return str;\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (e) {\n        return str;\n    }\n}\n/**\n * Determine if value is a Date.\n */\nfunction isDate(val) {\n    return __toString.call(val) === \"[object Date]\";\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb29raWUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSyxrQ0FBa0MsS0FBSztBQUNoRztBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQix1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsSUFBSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZUFBZTtBQUM1RTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZUFBZTtBQUM1RTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxtRUFBbUUsaUJBQWlCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLG1FQUFtRSxpQkFBaUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGx1Y2FzXFxPbmVEcml2ZVxcRG9jdW1lbnRvc1xcUHJvamV0b3NcXFNHQVxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcY29va2llXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggY29va2llLW5hbWUgaW4gUkZDIDYyNjUgc2VjIDQuMS4xXG4gKiBUaGlzIHJlZmVycyBvdXQgdG8gdGhlIG9ic29sZXRlZCBkZWZpbml0aW9uIG9mIHRva2VuIGluIFJGQyAyNjE2IHNlYyAyLjJcbiAqIHdoaWNoIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IHRoZSB0b2tlbiBkZWZpbml0aW9uIGluIFJGQyA3MjMwIGFwcGVuZGl4IEIuXG4gKlxuICogY29va2llLW5hbWUgICAgICAgPSB0b2tlblxuICogdG9rZW4gICAgICAgICAgICAgPSAxKnRjaGFyXG4gKiB0Y2hhciAgICAgICAgICAgICA9IFwiIVwiIC8gXCIjXCIgLyBcIiRcIiAvIFwiJVwiIC8gXCImXCIgLyBcIidcIiAvXG4gKiAgICAgICAgICAgICAgICAgICAgIFwiKlwiIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIC8gXCJeXCIgLyBcIl9cIiAvXG4gKiAgICAgICAgICAgICAgICAgICAgIFwiYFwiIC8gXCJ8XCIgLyBcIn5cIiAvIERJR0lUIC8gQUxQSEFcbiAqXG4gKiBOb3RlOiBBbGxvd2luZyBtb3JlIGNoYXJhY3RlcnMgLSBodHRwczovL2dpdGh1Yi5jb20vanNodHRwL2Nvb2tpZS9pc3N1ZXMvMTkxXG4gKiBBbGxvdyBzYW1lIHJhbmdlIGFzIGNvb2tpZSB2YWx1ZSwgZXhjZXB0IGA9YCwgd2hpY2ggZGVsaW1pdHMgZW5kIG9mIG5hbWUuXG4gKi9cbmNvbnN0IGNvb2tpZU5hbWVSZWdFeHAgPSAvXltcXHUwMDIxLVxcdTAwM0FcXHUwMDNDXFx1MDAzRS1cXHUwMDdFXSskLztcbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIGNvb2tpZS12YWx1ZSBpbiBSRkMgNjI2NSBzZWMgNC4xLjFcbiAqXG4gKiBjb29raWUtdmFsdWUgICAgICA9ICpjb29raWUtb2N0ZXQgLyAoIERRVU9URSAqY29va2llLW9jdGV0IERRVU9URSApXG4gKiBjb29raWUtb2N0ZXQgICAgICA9ICV4MjEgLyAleDIzLTJCIC8gJXgyRC0zQSAvICV4M0MtNUIgLyAleDVELTdFXG4gKiAgICAgICAgICAgICAgICAgICAgIDsgVVMtQVNDSUkgY2hhcmFjdGVycyBleGNsdWRpbmcgQ1RMcyxcbiAqICAgICAgICAgICAgICAgICAgICAgOyB3aGl0ZXNwYWNlIERRVU9URSwgY29tbWEsIHNlbWljb2xvbixcbiAqICAgICAgICAgICAgICAgICAgICAgOyBhbmQgYmFja3NsYXNoXG4gKlxuICogQWxsb3dpbmcgbW9yZSBjaGFyYWN0ZXJzOiBodHRwczovL2dpdGh1Yi5jb20vanNodHRwL2Nvb2tpZS9pc3N1ZXMvMTkxXG4gKiBDb21tYSwgYmFja3NsYXNoLCBhbmQgRFFVT1RFIGFyZSBub3QgcGFydCBvZiB0aGUgcGFyc2luZyBhbGdvcml0aG0uXG4gKi9cbmNvbnN0IGNvb2tpZVZhbHVlUmVnRXhwID0gL15bXFx1MDAyMS1cXHUwMDNBXFx1MDAzQy1cXHUwMDdFXSokLztcbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIGRvbWFpbi12YWx1ZSBpbiBSRkMgNjI2NSBzZWMgNC4xLjFcbiAqXG4gKiBkb21haW4tdmFsdWUgICAgICA9IDxzdWJkb21haW4+XG4gKiAgICAgICAgICAgICAgICAgICAgIDsgZGVmaW5lZCBpbiBbUkZDMTAzNF0sIFNlY3Rpb24gMy41LCBhc1xuICogICAgICAgICAgICAgICAgICAgICA7IGVuaGFuY2VkIGJ5IFtSRkMxMTIzXSwgU2VjdGlvbiAyLjFcbiAqIDxzdWJkb21haW4+ICAgICAgID0gPGxhYmVsPiB8IDxzdWJkb21haW4+IFwiLlwiIDxsYWJlbD5cbiAqIDxsYWJlbD4gICAgICAgICAgID0gPGxldC1kaWc+IFsgWyA8bGRoLXN0cj4gXSA8bGV0LWRpZz4gXVxuICogICAgICAgICAgICAgICAgICAgICBMYWJlbHMgbXVzdCBiZSA2MyBjaGFyYWN0ZXJzIG9yIGxlc3MuXG4gKiAgICAgICAgICAgICAgICAgICAgICdsZXQtZGlnJyBub3QgJ2xldHRlcicgaW4gdGhlIGZpcnN0IGNoYXIsIHBlciBSRkMxMTIzXG4gKiA8bGRoLXN0cj4gICAgICAgICA9IDxsZXQtZGlnLWh5cD4gfCA8bGV0LWRpZy1oeXA+IDxsZGgtc3RyPlxuICogPGxldC1kaWctaHlwPiAgICAgPSA8bGV0LWRpZz4gfCBcIi1cIlxuICogPGxldC1kaWc+ICAgICAgICAgPSA8bGV0dGVyPiB8IDxkaWdpdD5cbiAqIDxsZXR0ZXI+ICAgICAgICAgID0gYW55IG9uZSBvZiB0aGUgNTIgYWxwaGFiZXRpYyBjaGFyYWN0ZXJzIEEgdGhyb3VnaCBaIGluXG4gKiAgICAgICAgICAgICAgICAgICAgIHVwcGVyIGNhc2UgYW5kIGEgdGhyb3VnaCB6IGluIGxvd2VyIGNhc2VcbiAqIDxkaWdpdD4gICAgICAgICAgID0gYW55IG9uZSBvZiB0aGUgdGVuIGRpZ2l0cyAwIHRocm91Z2ggOVxuICpcbiAqIEtlZXAgc3VwcG9ydCBmb3IgbGVhZGluZyBkb3Q6IGh0dHBzOi8vZ2l0aHViLmNvbS9qc2h0dHAvY29va2llL2lzc3Vlcy8xNzNcbiAqXG4gKiA+IChOb3RlIHRoYXQgYSBsZWFkaW5nICV4MkUgKFwiLlwiKSwgaWYgcHJlc2VudCwgaXMgaWdub3JlZCBldmVuIHRob3VnaCB0aGF0XG4gKiBjaGFyYWN0ZXIgaXMgbm90IHBlcm1pdHRlZCwgYnV0IGEgdHJhaWxpbmcgJXgyRSAoXCIuXCIpLCBpZiBwcmVzZW50LCB3aWxsXG4gKiBjYXVzZSB0aGUgdXNlciBhZ2VudCB0byBpZ25vcmUgdGhlIGF0dHJpYnV0ZS4pXG4gKi9cbmNvbnN0IGRvbWFpblZhbHVlUmVnRXhwID0gL14oWy5dP1thLXowLTldKFthLXowLTktXXswLDYxfVthLXowLTldKT8pKFsuXVthLXowLTldKFthLXowLTktXXswLDYxfVthLXowLTldKT8pKiQvaTtcbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIHBhdGgtdmFsdWUgaW4gUkZDIDYyNjUgc2VjIDQuMS4xXG4gKlxuICogcGF0aC12YWx1ZSAgICAgICAgPSA8YW55IENIQVIgZXhjZXB0IENUTHMgb3IgXCI7XCI+XG4gKiBDSEFSICAgICAgICAgICAgICA9ICV4MDEtN0ZcbiAqICAgICAgICAgICAgICAgICAgICAgOyBkZWZpbmVkIGluIFJGQyA1MjM0IGFwcGVuZGl4IEIuMVxuICovXG5jb25zdCBwYXRoVmFsdWVSZWdFeHAgPSAvXltcXHUwMDIwLVxcdTAwM0FcXHUwMDNELVxcdTAwN0VdKiQvO1xuY29uc3QgX190b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCBOdWxsT2JqZWN0ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgY29uc3QgQyA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBDLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuIEM7XG59KSgpO1xuLyoqXG4gKiBQYXJzZSBhIGNvb2tpZSBoZWFkZXIuXG4gKlxuICogUGFyc2UgdGhlIGdpdmVuIGNvb2tpZSBoZWFkZXIgc3RyaW5nIGludG8gYW4gb2JqZWN0XG4gKiBUaGUgb2JqZWN0IGhhcyB0aGUgdmFyaW91cyBjb29raWVzIGFzIGtleXMobmFtZXMpID0+IHZhbHVlc1xuICovXG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvYmogPSBuZXcgTnVsbE9iamVjdCgpO1xuICAgIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgLy8gUkZDIDYyNjUgc2VjIDQuMS4xLCBSRkMgMjYxNiAyLjIgZGVmaW5lcyBhIGNvb2tpZSBuYW1lIGNvbnNpc3RzIG9mIG9uZSBjaGFyIG1pbmltdW0sIHBsdXMgJz0nLlxuICAgIGlmIChsZW4gPCAyKVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIGNvbnN0IGRlYyA9IG9wdGlvbnM/LmRlY29kZSB8fCBkZWNvZGU7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBkbyB7XG4gICAgICAgIGNvbnN0IGVxSWR4ID0gc3RyLmluZGV4T2YoXCI9XCIsIGluZGV4KTtcbiAgICAgICAgaWYgKGVxSWR4ID09PSAtMSlcbiAgICAgICAgICAgIGJyZWFrOyAvLyBObyBtb3JlIGNvb2tpZSBwYWlycy5cbiAgICAgICAgY29uc3QgY29sb25JZHggPSBzdHIuaW5kZXhPZihcIjtcIiwgaW5kZXgpO1xuICAgICAgICBjb25zdCBlbmRJZHggPSBjb2xvbklkeCA9PT0gLTEgPyBsZW4gOiBjb2xvbklkeDtcbiAgICAgICAgaWYgKGVxSWR4ID4gZW5kSWR4KSB7XG4gICAgICAgICAgICAvLyBiYWNrdHJhY2sgb24gcHJpb3Igc2VtaWNvbG9uXG4gICAgICAgICAgICBpbmRleCA9IHN0ci5sYXN0SW5kZXhPZihcIjtcIiwgZXFJZHggLSAxKSArIDE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlTdGFydElkeCA9IHN0YXJ0SW5kZXgoc3RyLCBpbmRleCwgZXFJZHgpO1xuICAgICAgICBjb25zdCBrZXlFbmRJZHggPSBlbmRJbmRleChzdHIsIGVxSWR4LCBrZXlTdGFydElkeCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHN0ci5zbGljZShrZXlTdGFydElkeCwga2V5RW5kSWR4KTtcbiAgICAgICAgLy8gb25seSBhc3NpZ24gb25jZVxuICAgICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHZhbFN0YXJ0SWR4ID0gc3RhcnRJbmRleChzdHIsIGVxSWR4ICsgMSwgZW5kSWR4KTtcbiAgICAgICAgICAgIGxldCB2YWxFbmRJZHggPSBlbmRJbmRleChzdHIsIGVuZElkeCwgdmFsU3RhcnRJZHgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkZWMoc3RyLnNsaWNlKHZhbFN0YXJ0SWR4LCB2YWxFbmRJZHgpKTtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBlbmRJZHggKyAxO1xuICAgIH0gd2hpbGUgKGluZGV4IDwgbGVuKTtcbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gc3RhcnRJbmRleChzdHIsIGluZGV4LCBtYXgpIHtcbiAgICBkbyB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIGlmIChjb2RlICE9PSAweDIwIC8qICAgKi8gJiYgY29kZSAhPT0gMHgwOSAvKiBcXHQgKi8pXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSB3aGlsZSAoKytpbmRleCA8IG1heCk7XG4gICAgcmV0dXJuIG1heDtcbn1cbmZ1bmN0aW9uIGVuZEluZGV4KHN0ciwgaW5kZXgsIG1pbikge1xuICAgIHdoaWxlIChpbmRleCA+IG1pbikge1xuICAgICAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoLS1pbmRleCk7XG4gICAgICAgIGlmIChjb2RlICE9PSAweDIwIC8qICAgKi8gJiYgY29kZSAhPT0gMHgwOSAvKiBcXHQgKi8pXG4gICAgICAgICAgICByZXR1cm4gaW5kZXggKyAxO1xuICAgIH1cbiAgICByZXR1cm4gbWluO1xufVxuLyoqXG4gKiBTZXJpYWxpemUgZGF0YSBpbnRvIGEgY29va2llIGhlYWRlci5cbiAqXG4gKiBTZXJpYWxpemUgYSBuYW1lIHZhbHVlIHBhaXIgaW50byBhIGNvb2tpZSBzdHJpbmcgc3VpdGFibGUgZm9yXG4gKiBodHRwIGhlYWRlcnMuIEFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjb29raWUgcGFyYW1ldGVycy5cbiAqXG4gKiBzZXJpYWxpemUoJ2ZvbycsICdiYXInLCB7IGh0dHBPbmx5OiB0cnVlIH0pXG4gKiAgID0+IFwiZm9vPWJhcjsgaHR0cE9ubHlcIlxuICovXG5mdW5jdGlvbiBzZXJpYWxpemUobmFtZSwgdmFsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZW5jID0gb3B0aW9ucz8uZW5jb2RlIHx8IGVuY29kZVVSSUNvbXBvbmVudDtcbiAgICBpZiAoIWNvb2tpZU5hbWVSZWdFeHAudGVzdChuYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBhcmd1bWVudCBuYW1lIGlzIGludmFsaWQ6ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBlbmModmFsKTtcbiAgICBpZiAoIWNvb2tpZVZhbHVlUmVnRXhwLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGFyZ3VtZW50IHZhbCBpcyBpbnZhbGlkOiAke3ZhbH1gKTtcbiAgICB9XG4gICAgbGV0IHN0ciA9IG5hbWUgKyBcIj1cIiArIHZhbHVlO1xuICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICBpZiAob3B0aW9ucy5tYXhBZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5tYXhBZ2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBvcHRpb24gbWF4QWdlIGlzIGludmFsaWQ6ICR7b3B0aW9ucy5tYXhBZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IFwiOyBNYXgtQWdlPVwiICsgb3B0aW9ucy5tYXhBZ2U7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRvbWFpbikge1xuICAgICAgICBpZiAoIWRvbWFpblZhbHVlUmVnRXhwLnRlc3Qob3B0aW9ucy5kb21haW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBvcHRpb24gZG9tYWluIGlzIGludmFsaWQ6ICR7b3B0aW9ucy5kb21haW59YCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IFwiOyBEb21haW49XCIgKyBvcHRpb25zLmRvbWFpbjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucGF0aCkge1xuICAgICAgICBpZiAoIXBhdGhWYWx1ZVJlZ0V4cC50ZXN0KG9wdGlvbnMucGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYG9wdGlvbiBwYXRoIGlzIGludmFsaWQ6ICR7b3B0aW9ucy5wYXRofWApO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBcIjsgUGF0aD1cIiArIG9wdGlvbnMucGF0aDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZXhwaXJlcykge1xuICAgICAgICBpZiAoIWlzRGF0ZShvcHRpb25zLmV4cGlyZXMpIHx8XG4gICAgICAgICAgICAhTnVtYmVyLmlzRmluaXRlKG9wdGlvbnMuZXhwaXJlcy52YWx1ZU9mKCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBvcHRpb24gZXhwaXJlcyBpcyBpbnZhbGlkOiAke29wdGlvbnMuZXhwaXJlc31gKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gXCI7IEV4cGlyZXM9XCIgKyBvcHRpb25zLmV4cGlyZXMudG9VVENTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaHR0cE9ubHkpIHtcbiAgICAgICAgc3RyICs9IFwiOyBIdHRwT25seVwiO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zZWN1cmUpIHtcbiAgICAgICAgc3RyICs9IFwiOyBTZWN1cmVcIjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucGFydGl0aW9uZWQpIHtcbiAgICAgICAgc3RyICs9IFwiOyBQYXJ0aXRpb25lZFwiO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wcmlvcml0eSkge1xuICAgICAgICBjb25zdCBwcmlvcml0eSA9IHR5cGVvZiBvcHRpb25zLnByaW9yaXR5ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IG9wdGlvbnMucHJpb3JpdHkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHN3aXRjaCAocHJpb3JpdHkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJsb3dcIjpcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCI7IFByaW9yaXR5PUxvd1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1lZGl1bVwiOlxuICAgICAgICAgICAgICAgIHN0ciArPSBcIjsgUHJpb3JpdHk9TWVkaXVtXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaGlnaFwiOlxuICAgICAgICAgICAgICAgIHN0ciArPSBcIjsgUHJpb3JpdHk9SGlnaFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBvcHRpb24gcHJpb3JpdHkgaXMgaW52YWxpZDogJHtvcHRpb25zLnByaW9yaXR5fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNhbWVTaXRlKSB7XG4gICAgICAgIGNvbnN0IHNhbWVTaXRlID0gdHlwZW9mIG9wdGlvbnMuc2FtZVNpdGUgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gb3B0aW9ucy5zYW1lU2l0ZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICA6IG9wdGlvbnMuc2FtZVNpdGU7XG4gICAgICAgIHN3aXRjaCAoc2FtZVNpdGUpIHtcbiAgICAgICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpY3RcIjpcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCI7IFNhbWVTaXRlPVN0cmljdFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImxheFwiOlxuICAgICAgICAgICAgICAgIHN0ciArPSBcIjsgU2FtZVNpdGU9TGF4XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgICAgIHN0ciArPSBcIjsgU2FtZVNpdGU9Tm9uZVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBvcHRpb24gc2FtZVNpdGUgaXMgaW52YWxpZDogJHtvcHRpb25zLnNhbWVTaXRlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4vKipcbiAqIFVSTC1kZWNvZGUgc3RyaW5nIHZhbHVlLiBPcHRpbWl6ZWQgdG8gc2tpcCBuYXRpdmUgY2FsbCB3aGVuIG5vICUuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoXCIlXCIpID09PSAtMSlcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdmFsdWUgaXMgYSBEYXRlLlxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gICAgcmV0dXJuIF9fdG9TdHJpbmcuY2FsbCh2YWwpID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/cookie/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Clucas%5C%5COneDrive%5C%5CDocumentos%5C%5CProjetos%5C%5CSGA%5C%5Cfrontend%5C%5Capp%5C%5Cpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Clucas%5C%5COneDrive%5C%5CDocumentos%5C%5CProjetos%5C%5CSGA%5C%5Cfrontend%5C%5Capp%5C%5Cpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.js */ \"(app-pages-browser)/./app/page.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDbHVjYXMlNUMlNUNPbmVEcml2ZSU1QyU1Q0RvY3VtZW50b3MlNUMlNUNQcm9qZXRvcyU1QyU1Q1NHQSU1QyU1Q2Zyb250ZW5kJTVDJTVDYXBwJTVDJTVDcGFnZS5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLG9KQUFrSCIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcbHVjYXNcXFxcT25lRHJpdmVcXFxcRG9jdW1lbnRvc1xcXFxQcm9qZXRvc1xcXFxTR0FcXFxcZnJvbnRlbmRcXFxcYXBwXFxcXHBhZ2UuanNcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Clucas%5C%5COneDrive%5C%5CDocumentos%5C%5CProjetos%5C%5CSGA%5C%5Cfrontend%5C%5Capp%5C%5Cpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQyxPQUFPO0FBQ3pFO0FBQ0EsZ0dBQWdHLFNBQVMsVUFBVSxzRkFBc0YsYUFBYSxVQUFVLFVBQVU7QUFDMU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsdWNhc1xcT25lRHJpdmVcXERvY3VtZW50b3NcXFByb2pldG9zXFxTR0FcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGNvbXBpbGVkXFxyZWFjdFxcY2pzXFxyZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfQUNUSVZJVFlfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJBY3Rpdml0eVwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29uc29sZTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5lcnJvcjtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICBcIk9iamVjdFwiO1xuICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QuY2FsbChcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQsXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGFza05hbWUodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHJldHVybiBcIjw+XCI7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFXG4gICAgICApXG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBcIjxcIiArIG5hbWUgKyBcIj5cIiA6IFwiPC4uLj5cIjtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVua25vd25Pd25lcigpIHtcbiAgICAgIHJldHVybiBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29uZmlnLmtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gICAgICBmdW5jdGlvbiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkoKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIHx8XG4gICAgICAgICAgKChzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3BlY2lhbC1wcm9wcylcIixcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSAhMDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nKCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodGhpcy50eXBlKTtcbiAgICAgIGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgKChkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQWNjZXNzaW5nIGVsZW1lbnQucmVmIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiByZWYgaXMgbm93IGEgcmVndWxhciBwcm9wLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgSlNYIEVsZW1lbnQgdHlwZSBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiXG4gICAgICAgICkpO1xuICAgICAgY29tcG9uZW50TmFtZSA9IHRoaXMucHJvcHMucmVmO1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29tcG9uZW50TmFtZSA/IGNvbXBvbmVudE5hbWUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFjdEVsZW1lbnQoXG4gICAgICB0eXBlLFxuICAgICAga2V5LFxuICAgICAgc2VsZixcbiAgICAgIHNvdXJjZSxcbiAgICAgIG93bmVyLFxuICAgICAgcHJvcHMsXG4gICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICBzZWxmID0gcHJvcHMucmVmO1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgX293bmVyOiBvd25lclxuICAgICAgfTtcbiAgICAgIG51bGwgIT09ICh2b2lkIDAgIT09IHNlbGYgPyBzZWxmIDogbnVsbClcbiAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQ6IGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICB0eXBlLl9zdG9yZSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdTdGFja1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1N0YWNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1Rhc2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdUYXNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZixcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID0gMDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbisrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbik7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5XCIgIT09IGs7XG4gICAgICAgIH0pO1xuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cbiAgICAgICAgICAwIDwga2V5cy5sZW5ndGhcbiAgICAgICAgICAgID8gXCJ7a2V5OiBzb21lS2V5LCBcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiXG4gICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gfHxcbiAgICAgICAgICAoKGtleXMgPVxuICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIHsuLi5wcm9wc30gLz5cXG5SZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsXG4gICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2b2lkIDAgIT09IG1heWJlS2V5ICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KSk7XG4gICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgY29uZmlnLmtleSkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBtYXliZUtleSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBzZWxmLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGdldE93bmVyKCksXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUpIHtcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgIG51bGwgIT09IG5vZGUgJiZcbiAgICAgICAgbm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFICYmXG4gICAgICAgIG5vZGUuX3N0b3JlICYmXG4gICAgICAgIChub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSAxKTtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICAgIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfQUNUSVZJVFlfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5hY3Rpdml0eVwiKSxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgY3JlYXRlVGFzayA9IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA/IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH07XG4gICAgUmVhY3QgPSB7XG4gICAgICByZWFjdF9zdGFja19ib3R0b21fZnJhbWU6IGZ1bmN0aW9uIChjYWxsU3RhY2tGb3JFcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbFN0YWNrRm9yRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1N0YWNrID0gUmVhY3QucmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lLmJpbmQoXG4gICAgICBSZWFjdCxcbiAgICAgIFVua25vd25Pd25lclxuICAgICkoKTtcbiAgICB2YXIgdW5rbm93bk93bmVyRGVidWdUYXNrID0gY3JlYXRlVGFzayhnZXRUYXNrTmFtZShVbmtub3duT3duZXIpKTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge307XG4gICAgZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG4gICAgZXhwb3J0cy5qc3hERVYgPSBmdW5jdGlvbiAoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgdmFyIHRyYWNrQWN0dWFsT3duZXIgPVxuICAgICAgICAxZTQgPiBSZWFjdFNoYXJlZEludGVybmFscy5yZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcysrO1xuICAgICAgcmV0dXJuIGpzeERFVkltcGwoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc2VsZixcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lclxuICAgICAgICAgID8gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIilcbiAgICAgICAgICA6IHVua25vd25Pd25lckRlYnVnU3RhY2ssXG4gICAgICAgIHRyYWNrQWN0dWFsT3duZXIgPyBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKHR5cGUpKSA6IHVua25vd25Pd25lckRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9O1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbHVjYXNcXE9uZURyaXZlXFxEb2N1bWVudG9zXFxQcm9qZXRvc1xcU0dBXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxccmVhY3RcXGpzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/qrcode.react/lib/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode.react/lib/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QRCodeCanvas: () => (/* binding */ QRCodeCanvas),\n/* harmony export */   QRCodeSVG: () => (/* binding */ QRCodeSVG)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n// src/index.tsx\n\n\n// src/third-party/qrcodegen/index.ts\n/**\n * @license QR Code generator library (TypeScript)\n * Copyright (c) Project Nayuki.\n * SPDX-License-Identifier: MIT\n */\nvar qrcodegen;\n((qrcodegen2) => {\n  const _QrCode = class _QrCode {\n    /*-- Constructor (low level) and fields --*/\n    // Creates a new QR Code with the given version number,\n    // error correction level, data codeword bytes, and mask number.\n    // This is a low-level API that most users should not use directly.\n    // A mid-level API is the encodeSegments() function.\n    constructor(version, errorCorrectionLevel, dataCodewords, msk) {\n      this.version = version;\n      this.errorCorrectionLevel = errorCorrectionLevel;\n      // The modules of this QR Code (false = light, true = dark).\n      // Immutable after constructor finishes. Accessed through getModule().\n      this.modules = [];\n      // Indicates function modules that are not subjected to masking. Discarded when constructor finishes.\n      this.isFunction = [];\n      if (version < _QrCode.MIN_VERSION || version > _QrCode.MAX_VERSION)\n        throw new RangeError(\"Version value out of range\");\n      if (msk < -1 || msk > 7)\n        throw new RangeError(\"Mask value out of range\");\n      this.size = version * 4 + 17;\n      let row = [];\n      for (let i = 0; i < this.size; i++)\n        row.push(false);\n      for (let i = 0; i < this.size; i++) {\n        this.modules.push(row.slice());\n        this.isFunction.push(row.slice());\n      }\n      this.drawFunctionPatterns();\n      const allCodewords = this.addEccAndInterleave(dataCodewords);\n      this.drawCodewords(allCodewords);\n      if (msk == -1) {\n        let minPenalty = 1e9;\n        for (let i = 0; i < 8; i++) {\n          this.applyMask(i);\n          this.drawFormatBits(i);\n          const penalty = this.getPenaltyScore();\n          if (penalty < minPenalty) {\n            msk = i;\n            minPenalty = penalty;\n          }\n          this.applyMask(i);\n        }\n      }\n      assert(0 <= msk && msk <= 7);\n      this.mask = msk;\n      this.applyMask(msk);\n      this.drawFormatBits(msk);\n      this.isFunction = [];\n    }\n    /*-- Static factory functions (high level) --*/\n    // Returns a QR Code representing the given Unicode text string at the given error correction level.\n    // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer\n    // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible\n    // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the\n    // ecl argument if it can be done without increasing the version.\n    static encodeText(text, ecl) {\n      const segs = qrcodegen2.QrSegment.makeSegments(text);\n      return _QrCode.encodeSegments(segs, ecl);\n    }\n    // Returns a QR Code representing the given binary data at the given error correction level.\n    // This function always encodes using the binary segment mode, not any text mode. The maximum number of\n    // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.\n    // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.\n    static encodeBinary(data, ecl) {\n      const seg = qrcodegen2.QrSegment.makeBytes(data);\n      return _QrCode.encodeSegments([seg], ecl);\n    }\n    /*-- Static factory functions (mid level) --*/\n    // Returns a QR Code representing the given segments with the given encoding parameters.\n    // The smallest possible QR Code version within the given range is automatically\n    // chosen for the output. Iff boostEcl is true, then the ECC level of the result\n    // may be higher than the ecl argument if it can be done without increasing the\n    // version. The mask number is either between 0 to 7 (inclusive) to force that\n    // mask, or -1 to automatically choose an appropriate mask (which may be slow).\n    // This function allows the user to create a custom sequence of segments that switches\n    // between modes (such as alphanumeric and byte) to encode text in less space.\n    // This is a mid-level API; the high-level API is encodeText() and encodeBinary().\n    static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {\n      if (!(_QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode.MAX_VERSION) || mask < -1 || mask > 7)\n        throw new RangeError(\"Invalid value\");\n      let version;\n      let dataUsedBits;\n      for (version = minVersion; ; version++) {\n        const dataCapacityBits2 = _QrCode.getNumDataCodewords(version, ecl) * 8;\n        const usedBits = QrSegment.getTotalBits(segs, version);\n        if (usedBits <= dataCapacityBits2) {\n          dataUsedBits = usedBits;\n          break;\n        }\n        if (version >= maxVersion)\n          throw new RangeError(\"Data too long\");\n      }\n      for (const newEcl of [_QrCode.Ecc.MEDIUM, _QrCode.Ecc.QUARTILE, _QrCode.Ecc.HIGH]) {\n        if (boostEcl && dataUsedBits <= _QrCode.getNumDataCodewords(version, newEcl) * 8)\n          ecl = newEcl;\n      }\n      let bb = [];\n      for (const seg of segs) {\n        appendBits(seg.mode.modeBits, 4, bb);\n        appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);\n        for (const b of seg.getData())\n          bb.push(b);\n      }\n      assert(bb.length == dataUsedBits);\n      const dataCapacityBits = _QrCode.getNumDataCodewords(version, ecl) * 8;\n      assert(bb.length <= dataCapacityBits);\n      appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n      appendBits(0, (8 - bb.length % 8) % 8, bb);\n      assert(bb.length % 8 == 0);\n      for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)\n        appendBits(padByte, 8, bb);\n      let dataCodewords = [];\n      while (dataCodewords.length * 8 < bb.length)\n        dataCodewords.push(0);\n      bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));\n      return new _QrCode(version, ecl, dataCodewords, mask);\n    }\n    /*-- Accessor methods --*/\n    // Returns the color of the module (pixel) at the given coordinates, which is false\n    // for light or true for dark. The top left corner has the coordinates (x=0, y=0).\n    // If the given coordinates are out of bounds, then false (light) is returned.\n    getModule(x, y) {\n      return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];\n    }\n    // Modified to expose modules for easy access\n    getModules() {\n      return this.modules;\n    }\n    /*-- Private helper methods for constructor: Drawing function modules --*/\n    // Reads this object's version field, and draws and marks all function modules.\n    drawFunctionPatterns() {\n      for (let i = 0; i < this.size; i++) {\n        this.setFunctionModule(6, i, i % 2 == 0);\n        this.setFunctionModule(i, 6, i % 2 == 0);\n      }\n      this.drawFinderPattern(3, 3);\n      this.drawFinderPattern(this.size - 4, 3);\n      this.drawFinderPattern(3, this.size - 4);\n      const alignPatPos = this.getAlignmentPatternPositions();\n      const numAlign = alignPatPos.length;\n      for (let i = 0; i < numAlign; i++) {\n        for (let j = 0; j < numAlign; j++) {\n          if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))\n            this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);\n        }\n      }\n      this.drawFormatBits(0);\n      this.drawVersion();\n    }\n    // Draws two copies of the format bits (with its own error correction code)\n    // based on the given mask and this object's error correction level field.\n    drawFormatBits(mask) {\n      const data = this.errorCorrectionLevel.formatBits << 3 | mask;\n      let rem = data;\n      for (let i = 0; i < 10; i++)\n        rem = rem << 1 ^ (rem >>> 9) * 1335;\n      const bits = (data << 10 | rem) ^ 21522;\n      assert(bits >>> 15 == 0);\n      for (let i = 0; i <= 5; i++)\n        this.setFunctionModule(8, i, getBit(bits, i));\n      this.setFunctionModule(8, 7, getBit(bits, 6));\n      this.setFunctionModule(8, 8, getBit(bits, 7));\n      this.setFunctionModule(7, 8, getBit(bits, 8));\n      for (let i = 9; i < 15; i++)\n        this.setFunctionModule(14 - i, 8, getBit(bits, i));\n      for (let i = 0; i < 8; i++)\n        this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));\n      for (let i = 8; i < 15; i++)\n        this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));\n      this.setFunctionModule(8, this.size - 8, true);\n    }\n    // Draws two copies of the version bits (with its own error correction code),\n    // based on this object's version field, iff 7 <= version <= 40.\n    drawVersion() {\n      if (this.version < 7)\n        return;\n      let rem = this.version;\n      for (let i = 0; i < 12; i++)\n        rem = rem << 1 ^ (rem >>> 11) * 7973;\n      const bits = this.version << 12 | rem;\n      assert(bits >>> 18 == 0);\n      for (let i = 0; i < 18; i++) {\n        const color = getBit(bits, i);\n        const a = this.size - 11 + i % 3;\n        const b = Math.floor(i / 3);\n        this.setFunctionModule(a, b, color);\n        this.setFunctionModule(b, a, color);\n      }\n    }\n    // Draws a 9*9 finder pattern including the border separator,\n    // with the center module at (x, y). Modules can be out of bounds.\n    drawFinderPattern(x, y) {\n      for (let dy = -4; dy <= 4; dy++) {\n        for (let dx = -4; dx <= 4; dx++) {\n          const dist = Math.max(Math.abs(dx), Math.abs(dy));\n          const xx = x + dx;\n          const yy = y + dy;\n          if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)\n            this.setFunctionModule(xx, yy, dist != 2 && dist != 4);\n        }\n      }\n    }\n    // Draws a 5*5 alignment pattern, with the center module\n    // at (x, y). All modules must be in bounds.\n    drawAlignmentPattern(x, y) {\n      for (let dy = -2; dy <= 2; dy++) {\n        for (let dx = -2; dx <= 2; dx++)\n          this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);\n      }\n    }\n    // Sets the color of a module and marks it as a function module.\n    // Only used by the constructor. Coordinates must be in bounds.\n    setFunctionModule(x, y, isDark) {\n      this.modules[y][x] = isDark;\n      this.isFunction[y][x] = true;\n    }\n    /*-- Private helper methods for constructor: Codewords and masking --*/\n    // Returns a new byte string representing the given data with the appropriate error correction\n    // codewords appended to it, based on this object's version and error correction level.\n    addEccAndInterleave(data) {\n      const ver = this.version;\n      const ecl = this.errorCorrectionLevel;\n      if (data.length != _QrCode.getNumDataCodewords(ver, ecl))\n        throw new RangeError(\"Invalid argument\");\n      const numBlocks = _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n      const blockEccLen = _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];\n      const rawCodewords = Math.floor(_QrCode.getNumRawDataModules(ver) / 8);\n      const numShortBlocks = numBlocks - rawCodewords % numBlocks;\n      const shortBlockLen = Math.floor(rawCodewords / numBlocks);\n      let blocks = [];\n      const rsDiv = _QrCode.reedSolomonComputeDivisor(blockEccLen);\n      for (let i = 0, k = 0; i < numBlocks; i++) {\n        let dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n        k += dat.length;\n        const ecc = _QrCode.reedSolomonComputeRemainder(dat, rsDiv);\n        if (i < numShortBlocks)\n          dat.push(0);\n        blocks.push(dat.concat(ecc));\n      }\n      let result = [];\n      for (let i = 0; i < blocks[0].length; i++) {\n        blocks.forEach((block, j) => {\n          if (i != shortBlockLen - blockEccLen || j >= numShortBlocks)\n            result.push(block[i]);\n        });\n      }\n      assert(result.length == rawCodewords);\n      return result;\n    }\n    // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n    // data area of this QR Code. Function modules need to be marked off before this is called.\n    drawCodewords(data) {\n      if (data.length != Math.floor(_QrCode.getNumRawDataModules(this.version) / 8))\n        throw new RangeError(\"Invalid argument\");\n      let i = 0;\n      for (let right = this.size - 1; right >= 1; right -= 2) {\n        if (right == 6)\n          right = 5;\n        for (let vert = 0; vert < this.size; vert++) {\n          for (let j = 0; j < 2; j++) {\n            const x = right - j;\n            const upward = (right + 1 & 2) == 0;\n            const y = upward ? this.size - 1 - vert : vert;\n            if (!this.isFunction[y][x] && i < data.length * 8) {\n              this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n              i++;\n            }\n          }\n        }\n      }\n      assert(i == data.length * 8);\n    }\n    // XORs the codeword modules in this QR Code with the given mask pattern.\n    // The function modules must be marked and the codeword bits must be drawn\n    // before masking. Due to the arithmetic of XOR, calling applyMask() with\n    // the same mask value a second time will undo the mask. A final well-formed\n    // QR Code needs exactly one (not zero, two, etc.) mask applied.\n    applyMask(mask) {\n      if (mask < 0 || mask > 7)\n        throw new RangeError(\"Mask value out of range\");\n      for (let y = 0; y < this.size; y++) {\n        for (let x = 0; x < this.size; x++) {\n          let invert;\n          switch (mask) {\n            case 0:\n              invert = (x + y) % 2 == 0;\n              break;\n            case 1:\n              invert = y % 2 == 0;\n              break;\n            case 2:\n              invert = x % 3 == 0;\n              break;\n            case 3:\n              invert = (x + y) % 3 == 0;\n              break;\n            case 4:\n              invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;\n              break;\n            case 5:\n              invert = x * y % 2 + x * y % 3 == 0;\n              break;\n            case 6:\n              invert = (x * y % 2 + x * y % 3) % 2 == 0;\n              break;\n            case 7:\n              invert = ((x + y) % 2 + x * y % 3) % 2 == 0;\n              break;\n            default:\n              throw new Error(\"Unreachable\");\n          }\n          if (!this.isFunction[y][x] && invert)\n            this.modules[y][x] = !this.modules[y][x];\n        }\n      }\n    }\n    // Calculates and returns the penalty score based on state of this QR Code's current modules.\n    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n    getPenaltyScore() {\n      let result = 0;\n      for (let y = 0; y < this.size; y++) {\n        let runColor = false;\n        let runX = 0;\n        let runHistory = [0, 0, 0, 0, 0, 0, 0];\n        for (let x = 0; x < this.size; x++) {\n          if (this.modules[y][x] == runColor) {\n            runX++;\n            if (runX == 5)\n              result += _QrCode.PENALTY_N1;\n            else if (runX > 5)\n              result++;\n          } else {\n            this.finderPenaltyAddHistory(runX, runHistory);\n            if (!runColor)\n              result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;\n            runColor = this.modules[y][x];\n            runX = 1;\n          }\n        }\n        result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode.PENALTY_N3;\n      }\n      for (let x = 0; x < this.size; x++) {\n        let runColor = false;\n        let runY = 0;\n        let runHistory = [0, 0, 0, 0, 0, 0, 0];\n        for (let y = 0; y < this.size; y++) {\n          if (this.modules[y][x] == runColor) {\n            runY++;\n            if (runY == 5)\n              result += _QrCode.PENALTY_N1;\n            else if (runY > 5)\n              result++;\n          } else {\n            this.finderPenaltyAddHistory(runY, runHistory);\n            if (!runColor)\n              result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;\n            runColor = this.modules[y][x];\n            runY = 1;\n          }\n        }\n        result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * _QrCode.PENALTY_N3;\n      }\n      for (let y = 0; y < this.size - 1; y++) {\n        for (let x = 0; x < this.size - 1; x++) {\n          const color = this.modules[y][x];\n          if (color == this.modules[y][x + 1] && color == this.modules[y + 1][x] && color == this.modules[y + 1][x + 1])\n            result += _QrCode.PENALTY_N2;\n        }\n      }\n      let dark = 0;\n      for (const row of this.modules)\n        dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);\n      const total = this.size * this.size;\n      const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n      assert(0 <= k && k <= 9);\n      result += k * _QrCode.PENALTY_N4;\n      assert(0 <= result && result <= 2568888);\n      return result;\n    }\n    /*-- Private helper functions --*/\n    // Returns an ascending list of positions of alignment patterns for this version number.\n    // Each position is in the range [0,177), and are used on both the x and y axes.\n    // This could be implemented as lookup table of 40 variable-length lists of integers.\n    getAlignmentPatternPositions() {\n      if (this.version == 1)\n        return [];\n      else {\n        const numAlign = Math.floor(this.version / 7) + 2;\n        const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\n        let result = [6];\n        for (let pos = this.size - 7; result.length < numAlign; pos -= step)\n          result.splice(1, 0, pos);\n        return result;\n      }\n    }\n    // Returns the number of data bits that can be stored in a QR Code of the given version number, after\n    // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.\n    // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.\n    static getNumRawDataModules(ver) {\n      if (ver < _QrCode.MIN_VERSION || ver > _QrCode.MAX_VERSION)\n        throw new RangeError(\"Version number out of range\");\n      let result = (16 * ver + 128) * ver + 64;\n      if (ver >= 2) {\n        const numAlign = Math.floor(ver / 7) + 2;\n        result -= (25 * numAlign - 10) * numAlign - 55;\n        if (ver >= 7)\n          result -= 36;\n      }\n      assert(208 <= result && result <= 29648);\n      return result;\n    }\n    // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any\n    // QR Code of the given version number and error correction level, with remainder bits discarded.\n    // This stateless pure function could be implemented as a (40*4)-cell lookup table.\n    static getNumDataCodewords(ver, ecl) {\n      return Math.floor(_QrCode.getNumRawDataModules(ver) / 8) - _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n    }\n    // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be\n    // implemented as a lookup table over all possible parameter values, instead of as an algorithm.\n    static reedSolomonComputeDivisor(degree) {\n      if (degree < 1 || degree > 255)\n        throw new RangeError(\"Degree out of range\");\n      let result = [];\n      for (let i = 0; i < degree - 1; i++)\n        result.push(0);\n      result.push(1);\n      let root = 1;\n      for (let i = 0; i < degree; i++) {\n        for (let j = 0; j < result.length; j++) {\n          result[j] = _QrCode.reedSolomonMultiply(result[j], root);\n          if (j + 1 < result.length)\n            result[j] ^= result[j + 1];\n        }\n        root = _QrCode.reedSolomonMultiply(root, 2);\n      }\n      return result;\n    }\n    // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.\n    static reedSolomonComputeRemainder(data, divisor) {\n      let result = divisor.map((_) => 0);\n      for (const b of data) {\n        const factor = b ^ result.shift();\n        result.push(0);\n        divisor.forEach((coef, i) => result[i] ^= _QrCode.reedSolomonMultiply(coef, factor));\n      }\n      return result;\n    }\n    // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result\n    // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.\n    static reedSolomonMultiply(x, y) {\n      if (x >>> 8 != 0 || y >>> 8 != 0)\n        throw new RangeError(\"Byte out of range\");\n      let z = 0;\n      for (let i = 7; i >= 0; i--) {\n        z = z << 1 ^ (z >>> 7) * 285;\n        z ^= (y >>> i & 1) * x;\n      }\n      assert(z >>> 8 == 0);\n      return z;\n    }\n    // Can only be called immediately after a light run is added, and\n    // returns either 0, 1, or 2. A helper function for getPenaltyScore().\n    finderPenaltyCountPatterns(runHistory) {\n      const n = runHistory[1];\n      assert(n <= this.size * 3);\n      const core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n      return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n    }\n    // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n    finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {\n      if (currentRunColor) {\n        this.finderPenaltyAddHistory(currentRunLength, runHistory);\n        currentRunLength = 0;\n      }\n      currentRunLength += this.size;\n      this.finderPenaltyAddHistory(currentRunLength, runHistory);\n      return this.finderPenaltyCountPatterns(runHistory);\n    }\n    // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n    finderPenaltyAddHistory(currentRunLength, runHistory) {\n      if (runHistory[0] == 0)\n        currentRunLength += this.size;\n      runHistory.pop();\n      runHistory.unshift(currentRunLength);\n    }\n  };\n  /*-- Constants and tables --*/\n  // The minimum version number supported in the QR Code Model 2 standard.\n  _QrCode.MIN_VERSION = 1;\n  // The maximum version number supported in the QR Code Model 2 standard.\n  _QrCode.MAX_VERSION = 40;\n  // For use in getPenaltyScore(), when evaluating which mask is best.\n  _QrCode.PENALTY_N1 = 3;\n  _QrCode.PENALTY_N2 = 3;\n  _QrCode.PENALTY_N3 = 40;\n  _QrCode.PENALTY_N4 = 10;\n  _QrCode.ECC_CODEWORDS_PER_BLOCK = [\n    // Version: (note that index 0 is for padding, and is set to an illegal value)\n    //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n    [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n    // Low\n    [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],\n    // Medium\n    [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n    // Quartile\n    [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]\n    // High\n  ];\n  _QrCode.NUM_ERROR_CORRECTION_BLOCKS = [\n    // Version: (note that index 0 is for padding, and is set to an illegal value)\n    //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n    [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],\n    // Low\n    [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],\n    // Medium\n    [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],\n    // Quartile\n    [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]\n    // High\n  ];\n  let QrCode = _QrCode;\n  qrcodegen2.QrCode = _QrCode;\n  function appendBits(val, len, bb) {\n    if (len < 0 || len > 31 || val >>> len != 0)\n      throw new RangeError(\"Value out of range\");\n    for (let i = len - 1; i >= 0; i--)\n      bb.push(val >>> i & 1);\n  }\n  function getBit(x, i) {\n    return (x >>> i & 1) != 0;\n  }\n  function assert(cond) {\n    if (!cond)\n      throw new Error(\"Assertion error\");\n  }\n  const _QrSegment = class _QrSegment {\n    /*-- Constructor (low level) and fields --*/\n    // Creates a new QR Code segment with the given attributes and data.\n    // The character count (numChars) must agree with the mode and the bit buffer length,\n    // but the constraint isn't checked. The given bit buffer is cloned and stored.\n    constructor(mode, numChars, bitData) {\n      this.mode = mode;\n      this.numChars = numChars;\n      this.bitData = bitData;\n      if (numChars < 0)\n        throw new RangeError(\"Invalid argument\");\n      this.bitData = bitData.slice();\n    }\n    /*-- Static factory functions (mid level) --*/\n    // Returns a segment representing the given binary data encoded in\n    // byte mode. All input byte arrays are acceptable. Any text string\n    // can be converted to UTF-8 bytes and encoded as a byte mode segment.\n    static makeBytes(data) {\n      let bb = [];\n      for (const b of data)\n        appendBits(b, 8, bb);\n      return new _QrSegment(_QrSegment.Mode.BYTE, data.length, bb);\n    }\n    // Returns a segment representing the given string of decimal digits encoded in numeric mode.\n    static makeNumeric(digits) {\n      if (!_QrSegment.isNumeric(digits))\n        throw new RangeError(\"String contains non-numeric characters\");\n      let bb = [];\n      for (let i = 0; i < digits.length; ) {\n        const n = Math.min(digits.length - i, 3);\n        appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);\n        i += n;\n      }\n      return new _QrSegment(_QrSegment.Mode.NUMERIC, digits.length, bb);\n    }\n    // Returns a segment representing the given text string encoded in alphanumeric mode.\n    // The characters allowed are: 0 to 9, A to Z (uppercase only), space,\n    // dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n    static makeAlphanumeric(text) {\n      if (!_QrSegment.isAlphanumeric(text))\n        throw new RangeError(\"String contains unencodable characters in alphanumeric mode\");\n      let bb = [];\n      let i;\n      for (i = 0; i + 2 <= text.length; i += 2) {\n        let temp = _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n        temp += _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n        appendBits(temp, 11, bb);\n      }\n      if (i < text.length)\n        appendBits(_QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n      return new _QrSegment(_QrSegment.Mode.ALPHANUMERIC, text.length, bb);\n    }\n    // Returns a new mutable list of zero or more segments to represent the given Unicode text string.\n    // The result may use various segment modes and switch modes to optimize the length of the bit stream.\n    static makeSegments(text) {\n      if (text == \"\")\n        return [];\n      else if (_QrSegment.isNumeric(text))\n        return [_QrSegment.makeNumeric(text)];\n      else if (_QrSegment.isAlphanumeric(text))\n        return [_QrSegment.makeAlphanumeric(text)];\n      else\n        return [_QrSegment.makeBytes(_QrSegment.toUtf8ByteArray(text))];\n    }\n    // Returns a segment representing an Extended Channel Interpretation\n    // (ECI) designator with the given assignment value.\n    static makeEci(assignVal) {\n      let bb = [];\n      if (assignVal < 0)\n        throw new RangeError(\"ECI assignment value out of range\");\n      else if (assignVal < 1 << 7)\n        appendBits(assignVal, 8, bb);\n      else if (assignVal < 1 << 14) {\n        appendBits(2, 2, bb);\n        appendBits(assignVal, 14, bb);\n      } else if (assignVal < 1e6) {\n        appendBits(6, 3, bb);\n        appendBits(assignVal, 21, bb);\n      } else\n        throw new RangeError(\"ECI assignment value out of range\");\n      return new _QrSegment(_QrSegment.Mode.ECI, 0, bb);\n    }\n    // Tests whether the given string can be encoded as a segment in numeric mode.\n    // A string is encodable iff each character is in the range 0 to 9.\n    static isNumeric(text) {\n      return _QrSegment.NUMERIC_REGEX.test(text);\n    }\n    // Tests whether the given string can be encoded as a segment in alphanumeric mode.\n    // A string is encodable iff each character is in the following set: 0 to 9, A to Z\n    // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n    static isAlphanumeric(text) {\n      return _QrSegment.ALPHANUMERIC_REGEX.test(text);\n    }\n    /*-- Methods --*/\n    // Returns a new copy of the data bits of this segment.\n    getData() {\n      return this.bitData.slice();\n    }\n    // (Package-private) Calculates and returns the number of bits needed to encode the given segments at\n    // the given version. The result is infinity if a segment has too many characters to fit its length field.\n    static getTotalBits(segs, version) {\n      let result = 0;\n      for (const seg of segs) {\n        const ccbits = seg.mode.numCharCountBits(version);\n        if (seg.numChars >= 1 << ccbits)\n          return Infinity;\n        result += 4 + ccbits + seg.bitData.length;\n      }\n      return result;\n    }\n    // Returns a new array of bytes representing the given string encoded in UTF-8.\n    static toUtf8ByteArray(str) {\n      str = encodeURI(str);\n      let result = [];\n      for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) != \"%\")\n          result.push(str.charCodeAt(i));\n        else {\n          result.push(parseInt(str.substring(i + 1, i + 3), 16));\n          i += 2;\n        }\n      }\n      return result;\n    }\n  };\n  /*-- Constants --*/\n  // Describes precisely all strings that are encodable in numeric mode.\n  _QrSegment.NUMERIC_REGEX = /^[0-9]*$/;\n  // Describes precisely all strings that are encodable in alphanumeric mode.\n  _QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\\/:-]*$/;\n  // The set of all legal characters in alphanumeric mode,\n  // where each character value maps to the index in the string.\n  _QrSegment.ALPHANUMERIC_CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n  let QrSegment = _QrSegment;\n  qrcodegen2.QrSegment = _QrSegment;\n})(qrcodegen || (qrcodegen = {}));\n((qrcodegen2) => {\n  let QrCode;\n  ((QrCode2) => {\n    const _Ecc = class _Ecc {\n      // The QR Code can tolerate about 30% erroneous codewords\n      /*-- Constructor and fields --*/\n      constructor(ordinal, formatBits) {\n        this.ordinal = ordinal;\n        this.formatBits = formatBits;\n      }\n    };\n    /*-- Constants --*/\n    _Ecc.LOW = new _Ecc(0, 1);\n    // The QR Code can tolerate about  7% erroneous codewords\n    _Ecc.MEDIUM = new _Ecc(1, 0);\n    // The QR Code can tolerate about 15% erroneous codewords\n    _Ecc.QUARTILE = new _Ecc(2, 3);\n    // The QR Code can tolerate about 25% erroneous codewords\n    _Ecc.HIGH = new _Ecc(3, 2);\n    let Ecc = _Ecc;\n    QrCode2.Ecc = _Ecc;\n  })(QrCode = qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));\n})(qrcodegen || (qrcodegen = {}));\n((qrcodegen2) => {\n  let QrSegment;\n  ((QrSegment2) => {\n    const _Mode = class _Mode {\n      /*-- Constructor and fields --*/\n      constructor(modeBits, numBitsCharCount) {\n        this.modeBits = modeBits;\n        this.numBitsCharCount = numBitsCharCount;\n      }\n      /*-- Method --*/\n      // (Package-private) Returns the bit width of the character count field for a segment in\n      // this mode in a QR Code at the given version number. The result is in the range [0, 16].\n      numCharCountBits(ver) {\n        return this.numBitsCharCount[Math.floor((ver + 7) / 17)];\n      }\n    };\n    /*-- Constants --*/\n    _Mode.NUMERIC = new _Mode(1, [10, 12, 14]);\n    _Mode.ALPHANUMERIC = new _Mode(2, [9, 11, 13]);\n    _Mode.BYTE = new _Mode(4, [8, 16, 16]);\n    _Mode.KANJI = new _Mode(8, [8, 10, 12]);\n    _Mode.ECI = new _Mode(7, [0, 0, 0]);\n    let Mode = _Mode;\n    QrSegment2.Mode = _Mode;\n  })(QrSegment = qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));\n})(qrcodegen || (qrcodegen = {}));\nvar qrcodegen_default = qrcodegen;\n\n// src/index.tsx\n/**\n * @license qrcode.react\n * Copyright (c) Paul O'Shannessy\n * SPDX-License-Identifier: ISC\n */\nvar ERROR_LEVEL_MAP = {\n  L: qrcodegen_default.QrCode.Ecc.LOW,\n  M: qrcodegen_default.QrCode.Ecc.MEDIUM,\n  Q: qrcodegen_default.QrCode.Ecc.QUARTILE,\n  H: qrcodegen_default.QrCode.Ecc.HIGH\n};\nvar DEFAULT_SIZE = 128;\nvar DEFAULT_LEVEL = \"L\";\nvar DEFAULT_BGCOLOR = \"#FFFFFF\";\nvar DEFAULT_FGCOLOR = \"#000000\";\nvar DEFAULT_INCLUDEMARGIN = false;\nvar DEFAULT_MINVERSION = 1;\nvar SPEC_MARGIN_SIZE = 4;\nvar DEFAULT_MARGIN_SIZE = 0;\nvar DEFAULT_IMG_SCALE = 0.1;\nfunction generatePath(modules, margin = 0) {\n  const ops = [];\n  modules.forEach(function(row, y) {\n    let start = null;\n    row.forEach(function(cell, x) {\n      if (!cell && start !== null) {\n        ops.push(\n          `M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`\n        );\n        start = null;\n        return;\n      }\n      if (x === row.length - 1) {\n        if (!cell) {\n          return;\n        }\n        if (start === null) {\n          ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);\n        } else {\n          ops.push(\n            `M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`\n          );\n        }\n        return;\n      }\n      if (cell && start === null) {\n        start = x;\n      }\n    });\n  });\n  return ops.join(\"\");\n}\nfunction excavateModules(modules, excavation) {\n  return modules.slice().map((row, y) => {\n    if (y < excavation.y || y >= excavation.y + excavation.h) {\n      return row;\n    }\n    return row.map((cell, x) => {\n      if (x < excavation.x || x >= excavation.x + excavation.w) {\n        return cell;\n      }\n      return false;\n    });\n  });\n}\nfunction getImageSettings(cells, size, margin, imageSettings) {\n  if (imageSettings == null) {\n    return null;\n  }\n  const numCells = cells.length + margin * 2;\n  const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);\n  const scale = numCells / size;\n  const w = (imageSettings.width || defaultSize) * scale;\n  const h = (imageSettings.height || defaultSize) * scale;\n  const x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;\n  const y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;\n  const opacity = imageSettings.opacity == null ? 1 : imageSettings.opacity;\n  let excavation = null;\n  if (imageSettings.excavate) {\n    let floorX = Math.floor(x);\n    let floorY = Math.floor(y);\n    let ceilW = Math.ceil(w + x - floorX);\n    let ceilH = Math.ceil(h + y - floorY);\n    excavation = { x: floorX, y: floorY, w: ceilW, h: ceilH };\n  }\n  const crossOrigin = imageSettings.crossOrigin;\n  return { x, y, h, w, excavation, opacity, crossOrigin };\n}\nfunction getMarginSize(includeMargin, marginSize) {\n  if (marginSize != null) {\n    return Math.max(Math.floor(marginSize), 0);\n  }\n  return includeMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;\n}\nfunction useQRCode({\n  value,\n  level,\n  minVersion,\n  includeMargin,\n  marginSize,\n  imageSettings,\n  size,\n  boostLevel\n}) {\n  let qrcode = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const values = Array.isArray(value) ? value : [value];\n    const segments = values.reduce((accum, v) => {\n      accum.push(...qrcodegen_default.QrSegment.makeSegments(v));\n      return accum;\n    }, []);\n    return qrcodegen_default.QrCode.encodeSegments(\n      segments,\n      ERROR_LEVEL_MAP[level],\n      minVersion,\n      void 0,\n      void 0,\n      boostLevel\n    );\n  }, [value, level, minVersion, boostLevel]);\n  const { cells, margin, numCells, calculatedImageSettings } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    let cells2 = qrcode.getModules();\n    const margin2 = getMarginSize(includeMargin, marginSize);\n    const numCells2 = cells2.length + margin2 * 2;\n    const calculatedImageSettings2 = getImageSettings(\n      cells2,\n      size,\n      margin2,\n      imageSettings\n    );\n    return {\n      cells: cells2,\n      margin: margin2,\n      numCells: numCells2,\n      calculatedImageSettings: calculatedImageSettings2\n    };\n  }, [qrcode, size, imageSettings, includeMargin, marginSize]);\n  return {\n    qrcode,\n    margin,\n    cells,\n    numCells,\n    calculatedImageSettings\n  };\n}\nvar SUPPORTS_PATH2D = function() {\n  try {\n    new Path2D().addPath(new Path2D());\n  } catch (e) {\n    return false;\n  }\n  return true;\n}();\nvar QRCodeCanvas = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function QRCodeCanvas2(props, forwardedRef) {\n    const _a = props, {\n      value,\n      size = DEFAULT_SIZE,\n      level = DEFAULT_LEVEL,\n      bgColor = DEFAULT_BGCOLOR,\n      fgColor = DEFAULT_FGCOLOR,\n      includeMargin = DEFAULT_INCLUDEMARGIN,\n      minVersion = DEFAULT_MINVERSION,\n      boostLevel,\n      marginSize,\n      imageSettings\n    } = _a, extraProps = __objRest(_a, [\n      \"value\",\n      \"size\",\n      \"level\",\n      \"bgColor\",\n      \"fgColor\",\n      \"includeMargin\",\n      \"minVersion\",\n      \"boostLevel\",\n      \"marginSize\",\n      \"imageSettings\"\n    ]);\n    const _b = extraProps, { style } = _b, otherProps = __objRest(_b, [\"style\"]);\n    const imgSrc = imageSettings == null ? void 0 : imageSettings.src;\n    const _canvas = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const _image = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const setCanvasRef = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n      (node) => {\n        _canvas.current = node;\n        if (typeof forwardedRef === \"function\") {\n          forwardedRef(node);\n        } else if (forwardedRef) {\n          forwardedRef.current = node;\n        }\n      },\n      [forwardedRef]\n    );\n    const [isImgLoaded, setIsImageLoaded] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const { margin, cells, numCells, calculatedImageSettings } = useQRCode({\n      value,\n      level,\n      minVersion,\n      boostLevel,\n      includeMargin,\n      marginSize,\n      imageSettings,\n      size\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      if (_canvas.current != null) {\n        const canvas = _canvas.current;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) {\n          return;\n        }\n        let cellsToDraw = cells;\n        const image = _image.current;\n        const haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;\n        if (haveImageToRender) {\n          if (calculatedImageSettings.excavation != null) {\n            cellsToDraw = excavateModules(\n              cells,\n              calculatedImageSettings.excavation\n            );\n          }\n        }\n        const pixelRatio = window.devicePixelRatio || 1;\n        canvas.height = canvas.width = size * pixelRatio;\n        const scale = size / numCells * pixelRatio;\n        ctx.scale(scale, scale);\n        ctx.fillStyle = bgColor;\n        ctx.fillRect(0, 0, numCells, numCells);\n        ctx.fillStyle = fgColor;\n        if (SUPPORTS_PATH2D) {\n          ctx.fill(new Path2D(generatePath(cellsToDraw, margin)));\n        } else {\n          cells.forEach(function(row, rdx) {\n            row.forEach(function(cell, cdx) {\n              if (cell) {\n                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);\n              }\n            });\n          });\n        }\n        if (calculatedImageSettings) {\n          ctx.globalAlpha = calculatedImageSettings.opacity;\n        }\n        if (haveImageToRender) {\n          ctx.drawImage(\n            image,\n            calculatedImageSettings.x + margin,\n            calculatedImageSettings.y + margin,\n            calculatedImageSettings.w,\n            calculatedImageSettings.h\n          );\n        }\n      }\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      setIsImageLoaded(false);\n    }, [imgSrc]);\n    const canvasStyle = __spreadValues({ height: size, width: size }, style);\n    let img = null;\n    if (imgSrc != null) {\n      img = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        \"img\",\n        {\n          src: imgSrc,\n          key: imgSrc,\n          style: { display: \"none\" },\n          onLoad: () => {\n            setIsImageLoaded(true);\n          },\n          ref: _image,\n          crossOrigin: calculatedImageSettings == null ? void 0 : calculatedImageSettings.crossOrigin\n        }\n      );\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      \"canvas\",\n      __spreadValues({\n        style: canvasStyle,\n        height: size,\n        width: size,\n        ref: setCanvasRef,\n        role: \"img\"\n      }, otherProps)\n    ), img);\n  }\n);\nQRCodeCanvas.displayName = \"QRCodeCanvas\";\nvar QRCodeSVG = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function QRCodeSVG2(props, forwardedRef) {\n    const _a = props, {\n      value,\n      size = DEFAULT_SIZE,\n      level = DEFAULT_LEVEL,\n      bgColor = DEFAULT_BGCOLOR,\n      fgColor = DEFAULT_FGCOLOR,\n      includeMargin = DEFAULT_INCLUDEMARGIN,\n      minVersion = DEFAULT_MINVERSION,\n      boostLevel,\n      title,\n      marginSize,\n      imageSettings\n    } = _a, otherProps = __objRest(_a, [\n      \"value\",\n      \"size\",\n      \"level\",\n      \"bgColor\",\n      \"fgColor\",\n      \"includeMargin\",\n      \"minVersion\",\n      \"boostLevel\",\n      \"title\",\n      \"marginSize\",\n      \"imageSettings\"\n    ]);\n    const { margin, cells, numCells, calculatedImageSettings } = useQRCode({\n      value,\n      level,\n      minVersion,\n      boostLevel,\n      includeMargin,\n      marginSize,\n      imageSettings,\n      size\n    });\n    let cellsToDraw = cells;\n    let image = null;\n    if (imageSettings != null && calculatedImageSettings != null) {\n      if (calculatedImageSettings.excavation != null) {\n        cellsToDraw = excavateModules(\n          cells,\n          calculatedImageSettings.excavation\n        );\n      }\n      image = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        \"image\",\n        {\n          href: imageSettings.src,\n          height: calculatedImageSettings.h,\n          width: calculatedImageSettings.w,\n          x: calculatedImageSettings.x + margin,\n          y: calculatedImageSettings.y + margin,\n          preserveAspectRatio: \"none\",\n          opacity: calculatedImageSettings.opacity,\n          crossOrigin: calculatedImageSettings.crossOrigin\n        }\n      );\n    }\n    const fgPath = generatePath(cellsToDraw, margin);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      \"svg\",\n      __spreadValues({\n        height: size,\n        width: size,\n        viewBox: `0 0 ${numCells} ${numCells}`,\n        ref: forwardedRef,\n        role: \"img\"\n      }, otherProps),\n      !!title && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"title\", null, title),\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        \"path\",\n        {\n          fill: bgColor,\n          d: `M0,0 h${numCells}v${numCells}H0z`,\n          shapeRendering: \"crispEdges\"\n        }\n      ),\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { fill: fgColor, d: fgPath, shapeRendering: \"crispEdges\" }),\n      image\n    );\n  }\n);\nQRCodeSVG.displayName = \"QRCodeSVG\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9xcmNvZGUucmVhY3QvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQkFBMEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEMsd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQW1CLENBQUMsMkNBQWMsd0JBQXdCLGdEQUFtQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0RBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVUsRUFBRSxTQUFTO0FBQzdDO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsaUNBQWlDLGdEQUFtQjtBQUNwRCxzQkFBc0IsZ0RBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTLEdBQUcsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQW1CLFdBQVcsd0RBQXdEO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsdWNhc1xcT25lRHJpdmVcXERvY3VtZW50b3NcXFByb2pldG9zXFxTR0FcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHFyY29kZS5yZWFjdFxcbGliXFxlc21cXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vLyBzcmMvaW5kZXgudHN4XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy90aGlyZC1wYXJ0eS9xcmNvZGVnZW4vaW5kZXgudHNcbi8qKlxuICogQGxpY2Vuc2UgUVIgQ29kZSBnZW5lcmF0b3IgbGlicmFyeSAoVHlwZVNjcmlwdClcbiAqIENvcHlyaWdodCAoYykgUHJvamVjdCBOYXl1a2kuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4gKi9cbnZhciBxcmNvZGVnZW47XG4oKHFyY29kZWdlbjIpID0+IHtcbiAgY29uc3QgX1FyQ29kZSA9IGNsYXNzIF9RckNvZGUge1xuICAgIC8qLS0gQ29uc3RydWN0b3IgKGxvdyBsZXZlbCkgYW5kIGZpZWxkcyAtLSovXG4gICAgLy8gQ3JlYXRlcyBhIG5ldyBRUiBDb2RlIHdpdGggdGhlIGdpdmVuIHZlcnNpb24gbnVtYmVyLFxuICAgIC8vIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwsIGRhdGEgY29kZXdvcmQgYnl0ZXMsIGFuZCBtYXNrIG51bWJlci5cbiAgICAvLyBUaGlzIGlzIGEgbG93LWxldmVsIEFQSSB0aGF0IG1vc3QgdXNlcnMgc2hvdWxkIG5vdCB1c2UgZGlyZWN0bHkuXG4gICAgLy8gQSBtaWQtbGV2ZWwgQVBJIGlzIHRoZSBlbmNvZGVTZWdtZW50cygpIGZ1bmN0aW9uLlxuICAgIGNvbnN0cnVjdG9yKHZlcnNpb24sIGVycm9yQ29ycmVjdGlvbkxldmVsLCBkYXRhQ29kZXdvcmRzLCBtc2spIHtcbiAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsID0gZXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG4gICAgICAvLyBUaGUgbW9kdWxlcyBvZiB0aGlzIFFSIENvZGUgKGZhbHNlID0gbGlnaHQsIHRydWUgPSBkYXJrKS5cbiAgICAgIC8vIEltbXV0YWJsZSBhZnRlciBjb25zdHJ1Y3RvciBmaW5pc2hlcy4gQWNjZXNzZWQgdGhyb3VnaCBnZXRNb2R1bGUoKS5cbiAgICAgIHRoaXMubW9kdWxlcyA9IFtdO1xuICAgICAgLy8gSW5kaWNhdGVzIGZ1bmN0aW9uIG1vZHVsZXMgdGhhdCBhcmUgbm90IHN1YmplY3RlZCB0byBtYXNraW5nLiBEaXNjYXJkZWQgd2hlbiBjb25zdHJ1Y3RvciBmaW5pc2hlcy5cbiAgICAgIHRoaXMuaXNGdW5jdGlvbiA9IFtdO1xuICAgICAgaWYgKHZlcnNpb24gPCBfUXJDb2RlLk1JTl9WRVJTSU9OIHx8IHZlcnNpb24gPiBfUXJDb2RlLk1BWF9WRVJTSU9OKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlZlcnNpb24gdmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgaWYgKG1zayA8IC0xIHx8IG1zayA+IDcpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTWFzayB2YWx1ZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICB0aGlzLnNpemUgPSB2ZXJzaW9uICogNCArIDE3O1xuICAgICAgbGV0IHJvdyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemU7IGkrKylcbiAgICAgICAgcm93LnB1c2goZmFsc2UpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemU7IGkrKykge1xuICAgICAgICB0aGlzLm1vZHVsZXMucHVzaChyb3cuc2xpY2UoKSk7XG4gICAgICAgIHRoaXMuaXNGdW5jdGlvbi5wdXNoKHJvdy5zbGljZSgpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd0Z1bmN0aW9uUGF0dGVybnMoKTtcbiAgICAgIGNvbnN0IGFsbENvZGV3b3JkcyA9IHRoaXMuYWRkRWNjQW5kSW50ZXJsZWF2ZShkYXRhQ29kZXdvcmRzKTtcbiAgICAgIHRoaXMuZHJhd0NvZGV3b3JkcyhhbGxDb2Rld29yZHMpO1xuICAgICAgaWYgKG1zayA9PSAtMSkge1xuICAgICAgICBsZXQgbWluUGVuYWx0eSA9IDFlOTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICB0aGlzLmFwcGx5TWFzayhpKTtcbiAgICAgICAgICB0aGlzLmRyYXdGb3JtYXRCaXRzKGkpO1xuICAgICAgICAgIGNvbnN0IHBlbmFsdHkgPSB0aGlzLmdldFBlbmFsdHlTY29yZSgpO1xuICAgICAgICAgIGlmIChwZW5hbHR5IDwgbWluUGVuYWx0eSkge1xuICAgICAgICAgICAgbXNrID0gaTtcbiAgICAgICAgICAgIG1pblBlbmFsdHkgPSBwZW5hbHR5O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFwcGx5TWFzayhpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXNzZXJ0KDAgPD0gbXNrICYmIG1zayA8PSA3KTtcbiAgICAgIHRoaXMubWFzayA9IG1zaztcbiAgICAgIHRoaXMuYXBwbHlNYXNrKG1zayk7XG4gICAgICB0aGlzLmRyYXdGb3JtYXRCaXRzKG1zayk7XG4gICAgICB0aGlzLmlzRnVuY3Rpb24gPSBbXTtcbiAgICB9XG4gICAgLyotLSBTdGF0aWMgZmFjdG9yeSBmdW5jdGlvbnMgKGhpZ2ggbGV2ZWwpIC0tKi9cbiAgICAvLyBSZXR1cm5zIGEgUVIgQ29kZSByZXByZXNlbnRpbmcgdGhlIGdpdmVuIFVuaWNvZGUgdGV4dCBzdHJpbmcgYXQgdGhlIGdpdmVuIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwuXG4gICAgLy8gQXMgYSBjb25zZXJ2YXRpdmUgdXBwZXIgYm91bmQsIHRoaXMgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byBzdWNjZWVkIGZvciBzdHJpbmdzIHRoYXQgaGF2ZSA3Mzggb3IgZmV3ZXJcbiAgICAvLyBVbmljb2RlIGNvZGUgcG9pbnRzIChub3QgVVRGLTE2IGNvZGUgdW5pdHMpIGlmIHRoZSBsb3cgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCBpcyB1c2VkLiBUaGUgc21hbGxlc3QgcG9zc2libGVcbiAgICAvLyBRUiBDb2RlIHZlcnNpb24gaXMgYXV0b21hdGljYWxseSBjaG9zZW4gZm9yIHRoZSBvdXRwdXQuIFRoZSBFQ0MgbGV2ZWwgb2YgdGhlIHJlc3VsdCBtYXkgYmUgaGlnaGVyIHRoYW4gdGhlXG4gICAgLy8gZWNsIGFyZ3VtZW50IGlmIGl0IGNhbiBiZSBkb25lIHdpdGhvdXQgaW5jcmVhc2luZyB0aGUgdmVyc2lvbi5cbiAgICBzdGF0aWMgZW5jb2RlVGV4dCh0ZXh0LCBlY2wpIHtcbiAgICAgIGNvbnN0IHNlZ3MgPSBxcmNvZGVnZW4yLlFyU2VnbWVudC5tYWtlU2VnbWVudHModGV4dCk7XG4gICAgICByZXR1cm4gX1FyQ29kZS5lbmNvZGVTZWdtZW50cyhzZWdzLCBlY2wpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgUVIgQ29kZSByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGJpbmFyeSBkYXRhIGF0IHRoZSBnaXZlbiBlcnJvciBjb3JyZWN0aW9uIGxldmVsLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWx3YXlzIGVuY29kZXMgdXNpbmcgdGhlIGJpbmFyeSBzZWdtZW50IG1vZGUsIG5vdCBhbnkgdGV4dCBtb2RlLiBUaGUgbWF4aW11bSBudW1iZXIgb2ZcbiAgICAvLyBieXRlcyBhbGxvd2VkIGlzIDI5NTMuIFRoZSBzbWFsbGVzdCBwb3NzaWJsZSBRUiBDb2RlIHZlcnNpb24gaXMgYXV0b21hdGljYWxseSBjaG9zZW4gZm9yIHRoZSBvdXRwdXQuXG4gICAgLy8gVGhlIEVDQyBsZXZlbCBvZiB0aGUgcmVzdWx0IG1heSBiZSBoaWdoZXIgdGhhbiB0aGUgZWNsIGFyZ3VtZW50IGlmIGl0IGNhbiBiZSBkb25lIHdpdGhvdXQgaW5jcmVhc2luZyB0aGUgdmVyc2lvbi5cbiAgICBzdGF0aWMgZW5jb2RlQmluYXJ5KGRhdGEsIGVjbCkge1xuICAgICAgY29uc3Qgc2VnID0gcXJjb2RlZ2VuMi5RclNlZ21lbnQubWFrZUJ5dGVzKGRhdGEpO1xuICAgICAgcmV0dXJuIF9RckNvZGUuZW5jb2RlU2VnbWVudHMoW3NlZ10sIGVjbCk7XG4gICAgfVxuICAgIC8qLS0gU3RhdGljIGZhY3RvcnkgZnVuY3Rpb25zIChtaWQgbGV2ZWwpIC0tKi9cbiAgICAvLyBSZXR1cm5zIGEgUVIgQ29kZSByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHNlZ21lbnRzIHdpdGggdGhlIGdpdmVuIGVuY29kaW5nIHBhcmFtZXRlcnMuXG4gICAgLy8gVGhlIHNtYWxsZXN0IHBvc3NpYmxlIFFSIENvZGUgdmVyc2lvbiB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAvLyBjaG9zZW4gZm9yIHRoZSBvdXRwdXQuIElmZiBib29zdEVjbCBpcyB0cnVlLCB0aGVuIHRoZSBFQ0MgbGV2ZWwgb2YgdGhlIHJlc3VsdFxuICAgIC8vIG1heSBiZSBoaWdoZXIgdGhhbiB0aGUgZWNsIGFyZ3VtZW50IGlmIGl0IGNhbiBiZSBkb25lIHdpdGhvdXQgaW5jcmVhc2luZyB0aGVcbiAgICAvLyB2ZXJzaW9uLiBUaGUgbWFzayBudW1iZXIgaXMgZWl0aGVyIGJldHdlZW4gMCB0byA3IChpbmNsdXNpdmUpIHRvIGZvcmNlIHRoYXRcbiAgICAvLyBtYXNrLCBvciAtMSB0byBhdXRvbWF0aWNhbGx5IGNob29zZSBhbiBhcHByb3ByaWF0ZSBtYXNrICh3aGljaCBtYXkgYmUgc2xvdykuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgdGhlIHVzZXIgdG8gY3JlYXRlIGEgY3VzdG9tIHNlcXVlbmNlIG9mIHNlZ21lbnRzIHRoYXQgc3dpdGNoZXNcbiAgICAvLyBiZXR3ZWVuIG1vZGVzIChzdWNoIGFzIGFscGhhbnVtZXJpYyBhbmQgYnl0ZSkgdG8gZW5jb2RlIHRleHQgaW4gbGVzcyBzcGFjZS5cbiAgICAvLyBUaGlzIGlzIGEgbWlkLWxldmVsIEFQSTsgdGhlIGhpZ2gtbGV2ZWwgQVBJIGlzIGVuY29kZVRleHQoKSBhbmQgZW5jb2RlQmluYXJ5KCkuXG4gICAgc3RhdGljIGVuY29kZVNlZ21lbnRzKHNlZ3MsIGVjbCwgbWluVmVyc2lvbiA9IDEsIG1heFZlcnNpb24gPSA0MCwgbWFzayA9IC0xLCBib29zdEVjbCA9IHRydWUpIHtcbiAgICAgIGlmICghKF9RckNvZGUuTUlOX1ZFUlNJT04gPD0gbWluVmVyc2lvbiAmJiBtaW5WZXJzaW9uIDw9IG1heFZlcnNpb24gJiYgbWF4VmVyc2lvbiA8PSBfUXJDb2RlLk1BWF9WRVJTSU9OKSB8fCBtYXNrIDwgLTEgfHwgbWFzayA+IDcpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB2YWx1ZVwiKTtcbiAgICAgIGxldCB2ZXJzaW9uO1xuICAgICAgbGV0IGRhdGFVc2VkQml0cztcbiAgICAgIGZvciAodmVyc2lvbiA9IG1pblZlcnNpb247IDsgdmVyc2lvbisrKSB7XG4gICAgICAgIGNvbnN0IGRhdGFDYXBhY2l0eUJpdHMyID0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIGVjbCkgKiA4O1xuICAgICAgICBjb25zdCB1c2VkQml0cyA9IFFyU2VnbWVudC5nZXRUb3RhbEJpdHMoc2VncywgdmVyc2lvbik7XG4gICAgICAgIGlmICh1c2VkQml0cyA8PSBkYXRhQ2FwYWNpdHlCaXRzMikge1xuICAgICAgICAgIGRhdGFVc2VkQml0cyA9IHVzZWRCaXRzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJzaW9uID49IG1heFZlcnNpb24pXG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEYXRhIHRvbyBsb25nXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBuZXdFY2wgb2YgW19RckNvZGUuRWNjLk1FRElVTSwgX1FyQ29kZS5FY2MuUVVBUlRJTEUsIF9RckNvZGUuRWNjLkhJR0hdKSB7XG4gICAgICAgIGlmIChib29zdEVjbCAmJiBkYXRhVXNlZEJpdHMgPD0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIG5ld0VjbCkgKiA4KVxuICAgICAgICAgIGVjbCA9IG5ld0VjbDtcbiAgICAgIH1cbiAgICAgIGxldCBiYiA9IFtdO1xuICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2Vncykge1xuICAgICAgICBhcHBlbmRCaXRzKHNlZy5tb2RlLm1vZGVCaXRzLCA0LCBiYik7XG4gICAgICAgIGFwcGVuZEJpdHMoc2VnLm51bUNoYXJzLCBzZWcubW9kZS5udW1DaGFyQ291bnRCaXRzKHZlcnNpb24pLCBiYik7XG4gICAgICAgIGZvciAoY29uc3QgYiBvZiBzZWcuZ2V0RGF0YSgpKVxuICAgICAgICAgIGJiLnB1c2goYik7XG4gICAgICB9XG4gICAgICBhc3NlcnQoYmIubGVuZ3RoID09IGRhdGFVc2VkQml0cyk7XG4gICAgICBjb25zdCBkYXRhQ2FwYWNpdHlCaXRzID0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIGVjbCkgKiA4O1xuICAgICAgYXNzZXJ0KGJiLmxlbmd0aCA8PSBkYXRhQ2FwYWNpdHlCaXRzKTtcbiAgICAgIGFwcGVuZEJpdHMoMCwgTWF0aC5taW4oNCwgZGF0YUNhcGFjaXR5Qml0cyAtIGJiLmxlbmd0aCksIGJiKTtcbiAgICAgIGFwcGVuZEJpdHMoMCwgKDggLSBiYi5sZW5ndGggJSA4KSAlIDgsIGJiKTtcbiAgICAgIGFzc2VydChiYi5sZW5ndGggJSA4ID09IDApO1xuICAgICAgZm9yIChsZXQgcGFkQnl0ZSA9IDIzNjsgYmIubGVuZ3RoIDwgZGF0YUNhcGFjaXR5Qml0czsgcGFkQnl0ZSBePSAyMzYgXiAxNylcbiAgICAgICAgYXBwZW5kQml0cyhwYWRCeXRlLCA4LCBiYik7XG4gICAgICBsZXQgZGF0YUNvZGV3b3JkcyA9IFtdO1xuICAgICAgd2hpbGUgKGRhdGFDb2Rld29yZHMubGVuZ3RoICogOCA8IGJiLmxlbmd0aClcbiAgICAgICAgZGF0YUNvZGV3b3Jkcy5wdXNoKDApO1xuICAgICAgYmIuZm9yRWFjaCgoYiwgaSkgPT4gZGF0YUNvZGV3b3Jkc1tpID4+PiAzXSB8PSBiIDw8IDcgLSAoaSAmIDcpKTtcbiAgICAgIHJldHVybiBuZXcgX1FyQ29kZSh2ZXJzaW9uLCBlY2wsIGRhdGFDb2Rld29yZHMsIG1hc2spO1xuICAgIH1cbiAgICAvKi0tIEFjY2Vzc29yIG1ldGhvZHMgLS0qL1xuICAgIC8vIFJldHVybnMgdGhlIGNvbG9yIG9mIHRoZSBtb2R1bGUgKHBpeGVsKSBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMsIHdoaWNoIGlzIGZhbHNlXG4gICAgLy8gZm9yIGxpZ2h0IG9yIHRydWUgZm9yIGRhcmsuIFRoZSB0b3AgbGVmdCBjb3JuZXIgaGFzIHRoZSBjb29yZGluYXRlcyAoeD0wLCB5PTApLlxuICAgIC8vIElmIHRoZSBnaXZlbiBjb29yZGluYXRlcyBhcmUgb3V0IG9mIGJvdW5kcywgdGhlbiBmYWxzZSAobGlnaHQpIGlzIHJldHVybmVkLlxuICAgIGdldE1vZHVsZSh4LCB5KSB7XG4gICAgICByZXR1cm4gMCA8PSB4ICYmIHggPCB0aGlzLnNpemUgJiYgMCA8PSB5ICYmIHkgPCB0aGlzLnNpemUgJiYgdGhpcy5tb2R1bGVzW3ldW3hdO1xuICAgIH1cbiAgICAvLyBNb2RpZmllZCB0byBleHBvc2UgbW9kdWxlcyBmb3IgZWFzeSBhY2Nlc3NcbiAgICBnZXRNb2R1bGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kdWxlcztcbiAgICB9XG4gICAgLyotLSBQcml2YXRlIGhlbHBlciBtZXRob2RzIGZvciBjb25zdHJ1Y3RvcjogRHJhd2luZyBmdW5jdGlvbiBtb2R1bGVzIC0tKi9cbiAgICAvLyBSZWFkcyB0aGlzIG9iamVjdCdzIHZlcnNpb24gZmllbGQsIGFuZCBkcmF3cyBhbmQgbWFya3MgYWxsIGZ1bmN0aW9uIG1vZHVsZXMuXG4gICAgZHJhd0Z1bmN0aW9uUGF0dGVybnMoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoNiwgaSwgaSAlIDIgPT0gMCk7XG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoaSwgNiwgaSAlIDIgPT0gMCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdGaW5kZXJQYXR0ZXJuKDMsIDMpO1xuICAgICAgdGhpcy5kcmF3RmluZGVyUGF0dGVybih0aGlzLnNpemUgLSA0LCAzKTtcbiAgICAgIHRoaXMuZHJhd0ZpbmRlclBhdHRlcm4oMywgdGhpcy5zaXplIC0gNCk7XG4gICAgICBjb25zdCBhbGlnblBhdFBvcyA9IHRoaXMuZ2V0QWxpZ25tZW50UGF0dGVyblBvc2l0aW9ucygpO1xuICAgICAgY29uc3QgbnVtQWxpZ24gPSBhbGlnblBhdFBvcy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUFsaWduOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1BbGlnbjsgaisrKSB7XG4gICAgICAgICAgaWYgKCEoaSA9PSAwICYmIGogPT0gMCB8fCBpID09IDAgJiYgaiA9PSBudW1BbGlnbiAtIDEgfHwgaSA9PSBudW1BbGlnbiAtIDEgJiYgaiA9PSAwKSlcbiAgICAgICAgICAgIHRoaXMuZHJhd0FsaWdubWVudFBhdHRlcm4oYWxpZ25QYXRQb3NbaV0sIGFsaWduUGF0UG9zW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5kcmF3Rm9ybWF0Qml0cygwKTtcbiAgICAgIHRoaXMuZHJhd1ZlcnNpb24oKTtcbiAgICB9XG4gICAgLy8gRHJhd3MgdHdvIGNvcGllcyBvZiB0aGUgZm9ybWF0IGJpdHMgKHdpdGggaXRzIG93biBlcnJvciBjb3JyZWN0aW9uIGNvZGUpXG4gICAgLy8gYmFzZWQgb24gdGhlIGdpdmVuIG1hc2sgYW5kIHRoaXMgb2JqZWN0J3MgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCBmaWVsZC5cbiAgICBkcmF3Rm9ybWF0Qml0cyhtYXNrKSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbC5mb3JtYXRCaXRzIDw8IDMgfCBtYXNrO1xuICAgICAgbGV0IHJlbSA9IGRhdGE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspXG4gICAgICAgIHJlbSA9IHJlbSA8PCAxIF4gKHJlbSA+Pj4gOSkgKiAxMzM1O1xuICAgICAgY29uc3QgYml0cyA9IChkYXRhIDw8IDEwIHwgcmVtKSBeIDIxNTIyO1xuICAgICAgYXNzZXJ0KGJpdHMgPj4+IDE1ID09IDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gNTsgaSsrKVxuICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIGksIGdldEJpdChiaXRzLCBpKSk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIDcsIGdldEJpdChiaXRzLCA2KSk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIDgsIGdldEJpdChiaXRzLCA3KSk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDcsIDgsIGdldEJpdChiaXRzLCA4KSk7XG4gICAgICBmb3IgKGxldCBpID0gOTsgaSA8IDE1OyBpKyspXG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoMTQgLSBpLCA4LCBnZXRCaXQoYml0cywgaSkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspXG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUodGhpcy5zaXplIC0gMSAtIGksIDgsIGdldEJpdChiaXRzLCBpKSk7XG4gICAgICBmb3IgKGxldCBpID0gODsgaSA8IDE1OyBpKyspXG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgdGhpcy5zaXplIC0gMTUgKyBpLCBnZXRCaXQoYml0cywgaSkpO1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg4LCB0aGlzLnNpemUgLSA4LCB0cnVlKTtcbiAgICB9XG4gICAgLy8gRHJhd3MgdHdvIGNvcGllcyBvZiB0aGUgdmVyc2lvbiBiaXRzICh3aXRoIGl0cyBvd24gZXJyb3IgY29ycmVjdGlvbiBjb2RlKSxcbiAgICAvLyBiYXNlZCBvbiB0aGlzIG9iamVjdCdzIHZlcnNpb24gZmllbGQsIGlmZiA3IDw9IHZlcnNpb24gPD0gNDAuXG4gICAgZHJhd1ZlcnNpb24oKSB7XG4gICAgICBpZiAodGhpcy52ZXJzaW9uIDwgNylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IHJlbSA9IHRoaXMudmVyc2lvbjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKylcbiAgICAgICAgcmVtID0gcmVtIDw8IDEgXiAocmVtID4+PiAxMSkgKiA3OTczO1xuICAgICAgY29uc3QgYml0cyA9IHRoaXMudmVyc2lvbiA8PCAxMiB8IHJlbTtcbiAgICAgIGFzc2VydChiaXRzID4+PiAxOCA9PSAwKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTg7IGkrKykge1xuICAgICAgICBjb25zdCBjb2xvciA9IGdldEJpdChiaXRzLCBpKTtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuc2l6ZSAtIDExICsgaSAlIDM7XG4gICAgICAgIGNvbnN0IGIgPSBNYXRoLmZsb29yKGkgLyAzKTtcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZShhLCBiLCBjb2xvcik7XG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoYiwgYSwgY29sb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBEcmF3cyBhIDkqOSBmaW5kZXIgcGF0dGVybiBpbmNsdWRpbmcgdGhlIGJvcmRlciBzZXBhcmF0b3IsXG4gICAgLy8gd2l0aCB0aGUgY2VudGVyIG1vZHVsZSBhdCAoeCwgeSkuIE1vZHVsZXMgY2FuIGJlIG91dCBvZiBib3VuZHMuXG4gICAgZHJhd0ZpbmRlclBhdHRlcm4oeCwgeSkge1xuICAgICAgZm9yIChsZXQgZHkgPSAtNDsgZHkgPD0gNDsgZHkrKykge1xuICAgICAgICBmb3IgKGxldCBkeCA9IC00OyBkeCA8PSA0OyBkeCsrKSB7XG4gICAgICAgICAgY29uc3QgZGlzdCA9IE1hdGgubWF4KE1hdGguYWJzKGR4KSwgTWF0aC5hYnMoZHkpKTtcbiAgICAgICAgICBjb25zdCB4eCA9IHggKyBkeDtcbiAgICAgICAgICBjb25zdCB5eSA9IHkgKyBkeTtcbiAgICAgICAgICBpZiAoMCA8PSB4eCAmJiB4eCA8IHRoaXMuc2l6ZSAmJiAwIDw9IHl5ICYmIHl5IDwgdGhpcy5zaXplKVxuICAgICAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSh4eCwgeXksIGRpc3QgIT0gMiAmJiBkaXN0ICE9IDQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIERyYXdzIGEgNSo1IGFsaWdubWVudCBwYXR0ZXJuLCB3aXRoIHRoZSBjZW50ZXIgbW9kdWxlXG4gICAgLy8gYXQgKHgsIHkpLiBBbGwgbW9kdWxlcyBtdXN0IGJlIGluIGJvdW5kcy5cbiAgICBkcmF3QWxpZ25tZW50UGF0dGVybih4LCB5KSB7XG4gICAgICBmb3IgKGxldCBkeSA9IC0yOyBkeSA8PSAyOyBkeSsrKSB7XG4gICAgICAgIGZvciAobGV0IGR4ID0gLTI7IGR4IDw9IDI7IGR4KyspXG4gICAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSh4ICsgZHgsIHkgKyBkeSwgTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeSkpICE9IDEpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXRzIHRoZSBjb2xvciBvZiBhIG1vZHVsZSBhbmQgbWFya3MgaXQgYXMgYSBmdW5jdGlvbiBtb2R1bGUuXG4gICAgLy8gT25seSB1c2VkIGJ5IHRoZSBjb25zdHJ1Y3Rvci4gQ29vcmRpbmF0ZXMgbXVzdCBiZSBpbiBib3VuZHMuXG4gICAgc2V0RnVuY3Rpb25Nb2R1bGUoeCwgeSwgaXNEYXJrKSB7XG4gICAgICB0aGlzLm1vZHVsZXNbeV1beF0gPSBpc0Rhcms7XG4gICAgICB0aGlzLmlzRnVuY3Rpb25beV1beF0gPSB0cnVlO1xuICAgIH1cbiAgICAvKi0tIFByaXZhdGUgaGVscGVyIG1ldGhvZHMgZm9yIGNvbnN0cnVjdG9yOiBDb2Rld29yZHMgYW5kIG1hc2tpbmcgLS0qL1xuICAgIC8vIFJldHVybnMgYSBuZXcgYnl0ZSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBkYXRhIHdpdGggdGhlIGFwcHJvcHJpYXRlIGVycm9yIGNvcnJlY3Rpb25cbiAgICAvLyBjb2Rld29yZHMgYXBwZW5kZWQgdG8gaXQsIGJhc2VkIG9uIHRoaXMgb2JqZWN0J3MgdmVyc2lvbiBhbmQgZXJyb3IgY29ycmVjdGlvbiBsZXZlbC5cbiAgICBhZGRFY2NBbmRJbnRlcmxlYXZlKGRhdGEpIHtcbiAgICAgIGNvbnN0IHZlciA9IHRoaXMudmVyc2lvbjtcbiAgICAgIGNvbnN0IGVjbCA9IHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggIT0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlciwgZWNsKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgICAgY29uc3QgbnVtQmxvY2tzID0gX1FyQ29kZS5OVU1fRVJST1JfQ09SUkVDVElPTl9CTE9DS1NbZWNsLm9yZGluYWxdW3Zlcl07XG4gICAgICBjb25zdCBibG9ja0VjY0xlbiA9IF9RckNvZGUuRUNDX0NPREVXT1JEU19QRVJfQkxPQ0tbZWNsLm9yZGluYWxdW3Zlcl07XG4gICAgICBjb25zdCByYXdDb2Rld29yZHMgPSBNYXRoLmZsb29yKF9RckNvZGUuZ2V0TnVtUmF3RGF0YU1vZHVsZXModmVyKSAvIDgpO1xuICAgICAgY29uc3QgbnVtU2hvcnRCbG9ja3MgPSBudW1CbG9ja3MgLSByYXdDb2Rld29yZHMgJSBudW1CbG9ja3M7XG4gICAgICBjb25zdCBzaG9ydEJsb2NrTGVuID0gTWF0aC5mbG9vcihyYXdDb2Rld29yZHMgLyBudW1CbG9ja3MpO1xuICAgICAgbGV0IGJsb2NrcyA9IFtdO1xuICAgICAgY29uc3QgcnNEaXYgPSBfUXJDb2RlLnJlZWRTb2xvbW9uQ29tcHV0ZURpdmlzb3IoYmxvY2tFY2NMZW4pO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGsgPSAwOyBpIDwgbnVtQmxvY2tzOyBpKyspIHtcbiAgICAgICAgbGV0IGRhdCA9IGRhdGEuc2xpY2UoaywgayArIHNob3J0QmxvY2tMZW4gLSBibG9ja0VjY0xlbiArIChpIDwgbnVtU2hvcnRCbG9ja3MgPyAwIDogMSkpO1xuICAgICAgICBrICs9IGRhdC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGVjYyA9IF9RckNvZGUucmVlZFNvbG9tb25Db21wdXRlUmVtYWluZGVyKGRhdCwgcnNEaXYpO1xuICAgICAgICBpZiAoaSA8IG51bVNob3J0QmxvY2tzKVxuICAgICAgICAgIGRhdC5wdXNoKDApO1xuICAgICAgICBibG9ja3MucHVzaChkYXQuY29uY2F0KGVjYykpO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3NbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmxvY2tzLmZvckVhY2goKGJsb2NrLCBqKSA9PiB7XG4gICAgICAgICAgaWYgKGkgIT0gc2hvcnRCbG9ja0xlbiAtIGJsb2NrRWNjTGVuIHx8IGogPj0gbnVtU2hvcnRCbG9ja3MpXG4gICAgICAgICAgICByZXN1bHQucHVzaChibG9ja1tpXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KHJlc3VsdC5sZW5ndGggPT0gcmF3Q29kZXdvcmRzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIERyYXdzIHRoZSBnaXZlbiBzZXF1ZW5jZSBvZiA4LWJpdCBjb2Rld29yZHMgKGRhdGEgYW5kIGVycm9yIGNvcnJlY3Rpb24pIG9udG8gdGhlIGVudGlyZVxuICAgIC8vIGRhdGEgYXJlYSBvZiB0aGlzIFFSIENvZGUuIEZ1bmN0aW9uIG1vZHVsZXMgbmVlZCB0byBiZSBtYXJrZWQgb2ZmIGJlZm9yZSB0aGlzIGlzIGNhbGxlZC5cbiAgICBkcmF3Q29kZXdvcmRzKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCAhPSBNYXRoLmZsb29yKF9RckNvZGUuZ2V0TnVtUmF3RGF0YU1vZHVsZXModGhpcy52ZXJzaW9uKSAvIDgpKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGxldCByaWdodCA9IHRoaXMuc2l6ZSAtIDE7IHJpZ2h0ID49IDE7IHJpZ2h0IC09IDIpIHtcbiAgICAgICAgaWYgKHJpZ2h0ID09IDYpXG4gICAgICAgICAgcmlnaHQgPSA1O1xuICAgICAgICBmb3IgKGxldCB2ZXJ0ID0gMDsgdmVydCA8IHRoaXMuc2l6ZTsgdmVydCsrKSB7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAyOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSByaWdodCAtIGo7XG4gICAgICAgICAgICBjb25zdCB1cHdhcmQgPSAocmlnaHQgKyAxICYgMikgPT0gMDtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB1cHdhcmQgPyB0aGlzLnNpemUgLSAxIC0gdmVydCA6IHZlcnQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNGdW5jdGlvblt5XVt4XSAmJiBpIDwgZGF0YS5sZW5ndGggKiA4KSB7XG4gICAgICAgICAgICAgIHRoaXMubW9kdWxlc1t5XVt4XSA9IGdldEJpdChkYXRhW2kgPj4+IDNdLCA3IC0gKGkgJiA3KSk7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFzc2VydChpID09IGRhdGEubGVuZ3RoICogOCk7XG4gICAgfVxuICAgIC8vIFhPUnMgdGhlIGNvZGV3b3JkIG1vZHVsZXMgaW4gdGhpcyBRUiBDb2RlIHdpdGggdGhlIGdpdmVuIG1hc2sgcGF0dGVybi5cbiAgICAvLyBUaGUgZnVuY3Rpb24gbW9kdWxlcyBtdXN0IGJlIG1hcmtlZCBhbmQgdGhlIGNvZGV3b3JkIGJpdHMgbXVzdCBiZSBkcmF3blxuICAgIC8vIGJlZm9yZSBtYXNraW5nLiBEdWUgdG8gdGhlIGFyaXRobWV0aWMgb2YgWE9SLCBjYWxsaW5nIGFwcGx5TWFzaygpIHdpdGhcbiAgICAvLyB0aGUgc2FtZSBtYXNrIHZhbHVlIGEgc2Vjb25kIHRpbWUgd2lsbCB1bmRvIHRoZSBtYXNrLiBBIGZpbmFsIHdlbGwtZm9ybWVkXG4gICAgLy8gUVIgQ29kZSBuZWVkcyBleGFjdGx5IG9uZSAobm90IHplcm8sIHR3bywgZXRjLikgbWFzayBhcHBsaWVkLlxuICAgIGFwcGx5TWFzayhtYXNrKSB7XG4gICAgICBpZiAobWFzayA8IDAgfHwgbWFzayA+IDcpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTWFzayB2YWx1ZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZTsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zaXplOyB4KyspIHtcbiAgICAgICAgICBsZXQgaW52ZXJ0O1xuICAgICAgICAgIHN3aXRjaCAobWFzaykge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpbnZlcnQgPSAoeCArIHkpICUgMiA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0geSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGludmVydCA9IHggJSAzID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBpbnZlcnQgPSAoeCArIHkpICUgMyA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKE1hdGguZmxvb3IoeCAvIDMpICsgTWF0aC5mbG9vcih5IC8gMikpICUgMiA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0geCAqIHkgJSAyICsgeCAqIHkgJSAzID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBpbnZlcnQgPSAoeCAqIHkgJSAyICsgeCAqIHkgJSAzKSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGludmVydCA9ICgoeCArIHkpICUgMiArIHggKiB5ICUgMykgJSAyID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWFjaGFibGVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5pc0Z1bmN0aW9uW3ldW3hdICYmIGludmVydClcbiAgICAgICAgICAgIHRoaXMubW9kdWxlc1t5XVt4XSA9ICF0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgcGVuYWx0eSBzY29yZSBiYXNlZCBvbiBzdGF0ZSBvZiB0aGlzIFFSIENvZGUncyBjdXJyZW50IG1vZHVsZXMuXG4gICAgLy8gVGhpcyBpcyB1c2VkIGJ5IHRoZSBhdXRvbWF0aWMgbWFzayBjaG9pY2UgYWxnb3JpdGhtIHRvIGZpbmQgdGhlIG1hc2sgcGF0dGVybiB0aGF0IHlpZWxkcyB0aGUgbG93ZXN0IHNjb3JlLlxuICAgIGdldFBlbmFsdHlTY29yZSgpIHtcbiAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemU7IHkrKykge1xuICAgICAgICBsZXQgcnVuQ29sb3IgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJ1blggPSAwO1xuICAgICAgICBsZXQgcnVuSGlzdG9yeSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemU7IHgrKykge1xuICAgICAgICAgIGlmICh0aGlzLm1vZHVsZXNbeV1beF0gPT0gcnVuQ29sb3IpIHtcbiAgICAgICAgICAgIHJ1blgrKztcbiAgICAgICAgICAgIGlmIChydW5YID09IDUpXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBfUXJDb2RlLlBFTkFMVFlfTjE7XG4gICAgICAgICAgICBlbHNlIGlmIChydW5YID4gNSlcbiAgICAgICAgICAgICAgcmVzdWx0Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkocnVuWCwgcnVuSGlzdG9yeSk7XG4gICAgICAgICAgICBpZiAoIXJ1bkNvbG9yKVxuICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5maW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyhydW5IaXN0b3J5KSAqIF9RckNvZGUuUEVOQUxUWV9OMztcbiAgICAgICAgICAgIHJ1bkNvbG9yID0gdGhpcy5tb2R1bGVzW3ldW3hdO1xuICAgICAgICAgICAgcnVuWCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudChydW5Db2xvciwgcnVuWCwgcnVuSGlzdG9yeSkgKiBfUXJDb2RlLlBFTkFMVFlfTjM7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZTsgeCsrKSB7XG4gICAgICAgIGxldCBydW5Db2xvciA9IGZhbHNlO1xuICAgICAgICBsZXQgcnVuWSA9IDA7XG4gICAgICAgIGxldCBydW5IaXN0b3J5ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZTsgeSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMubW9kdWxlc1t5XVt4XSA9PSBydW5Db2xvcikge1xuICAgICAgICAgICAgcnVuWSsrO1xuICAgICAgICAgICAgaWYgKHJ1blkgPT0gNSlcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IF9RckNvZGUuUEVOQUxUWV9OMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1blkgPiA1KVxuICAgICAgICAgICAgICByZXN1bHQrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5kZXJQZW5hbHR5QWRkSGlzdG9yeShydW5ZLCBydW5IaXN0b3J5KTtcbiAgICAgICAgICAgIGlmICghcnVuQ29sb3IpXG4gICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zKHJ1bkhpc3RvcnkpICogX1FyQ29kZS5QRU5BTFRZX04zO1xuICAgICAgICAgICAgcnVuQ29sb3IgPSB0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgICAgICAgICBydW5ZID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHRoaXMuZmluZGVyUGVuYWx0eVRlcm1pbmF0ZUFuZENvdW50KHJ1bkNvbG9yLCBydW5ZLCBydW5IaXN0b3J5KSAqIF9RckNvZGUuUEVOQUxUWV9OMztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplIC0gMTsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zaXplIC0gMTsgeCsrKSB7XG4gICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgICAgICAgaWYgKGNvbG9yID09IHRoaXMubW9kdWxlc1t5XVt4ICsgMV0gJiYgY29sb3IgPT0gdGhpcy5tb2R1bGVzW3kgKyAxXVt4XSAmJiBjb2xvciA9PSB0aGlzLm1vZHVsZXNbeSArIDFdW3ggKyAxXSlcbiAgICAgICAgICAgIHJlc3VsdCArPSBfUXJDb2RlLlBFTkFMVFlfTjI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBkYXJrID0gMDtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRoaXMubW9kdWxlcylcbiAgICAgICAgZGFyayA9IHJvdy5yZWR1Y2UoKHN1bSwgY29sb3IpID0+IHN1bSArIChjb2xvciA/IDEgOiAwKSwgZGFyayk7XG4gICAgICBjb25zdCB0b3RhbCA9IHRoaXMuc2l6ZSAqIHRoaXMuc2l6ZTtcbiAgICAgIGNvbnN0IGsgPSBNYXRoLmNlaWwoTWF0aC5hYnMoZGFyayAqIDIwIC0gdG90YWwgKiAxMCkgLyB0b3RhbCkgLSAxO1xuICAgICAgYXNzZXJ0KDAgPD0gayAmJiBrIDw9IDkpO1xuICAgICAgcmVzdWx0ICs9IGsgKiBfUXJDb2RlLlBFTkFMVFlfTjQ7XG4gICAgICBhc3NlcnQoMCA8PSByZXN1bHQgJiYgcmVzdWx0IDw9IDI1Njg4ODgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyotLSBQcml2YXRlIGhlbHBlciBmdW5jdGlvbnMgLS0qL1xuICAgIC8vIFJldHVybnMgYW4gYXNjZW5kaW5nIGxpc3Qgb2YgcG9zaXRpb25zIG9mIGFsaWdubWVudCBwYXR0ZXJucyBmb3IgdGhpcyB2ZXJzaW9uIG51bWJlci5cbiAgICAvLyBFYWNoIHBvc2l0aW9uIGlzIGluIHRoZSByYW5nZSBbMCwxNzcpLCBhbmQgYXJlIHVzZWQgb24gYm90aCB0aGUgeCBhbmQgeSBheGVzLlxuICAgIC8vIFRoaXMgY291bGQgYmUgaW1wbGVtZW50ZWQgYXMgbG9va3VwIHRhYmxlIG9mIDQwIHZhcmlhYmxlLWxlbmd0aCBsaXN0cyBvZiBpbnRlZ2Vycy5cbiAgICBnZXRBbGlnbm1lbnRQYXR0ZXJuUG9zaXRpb25zKCkge1xuICAgICAgaWYgKHRoaXMudmVyc2lvbiA9PSAxKVxuICAgICAgICByZXR1cm4gW107XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbnVtQWxpZ24gPSBNYXRoLmZsb29yKHRoaXMudmVyc2lvbiAvIDcpICsgMjtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMudmVyc2lvbiA9PSAzMiA/IDI2IDogTWF0aC5jZWlsKCh0aGlzLnZlcnNpb24gKiA0ICsgNCkgLyAobnVtQWxpZ24gKiAyIC0gMikpICogMjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFs2XTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdGhpcy5zaXplIC0gNzsgcmVzdWx0Lmxlbmd0aCA8IG51bUFsaWduOyBwb3MgLT0gc3RlcClcbiAgICAgICAgICByZXN1bHQuc3BsaWNlKDEsIDAsIHBvcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXRhIGJpdHMgdGhhdCBjYW4gYmUgc3RvcmVkIGluIGEgUVIgQ29kZSBvZiB0aGUgZ2l2ZW4gdmVyc2lvbiBudW1iZXIsIGFmdGVyXG4gICAgLy8gYWxsIGZ1bmN0aW9uIG1vZHVsZXMgYXJlIGV4Y2x1ZGVkLiBUaGlzIGluY2x1ZGVzIHJlbWFpbmRlciBiaXRzLCBzbyBpdCBtaWdodCBub3QgYmUgYSBtdWx0aXBsZSBvZiA4LlxuICAgIC8vIFRoZSByZXN1bHQgaXMgaW4gdGhlIHJhbmdlIFsyMDgsIDI5NjQ4XS4gVGhpcyBjb3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBhIDQwLWVudHJ5IGxvb2t1cCB0YWJsZS5cbiAgICBzdGF0aWMgZ2V0TnVtUmF3RGF0YU1vZHVsZXModmVyKSB7XG4gICAgICBpZiAodmVyIDwgX1FyQ29kZS5NSU5fVkVSU0lPTiB8fCB2ZXIgPiBfUXJDb2RlLk1BWF9WRVJTSU9OKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlZlcnNpb24gbnVtYmVyIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGxldCByZXN1bHQgPSAoMTYgKiB2ZXIgKyAxMjgpICogdmVyICsgNjQ7XG4gICAgICBpZiAodmVyID49IDIpIHtcbiAgICAgICAgY29uc3QgbnVtQWxpZ24gPSBNYXRoLmZsb29yKHZlciAvIDcpICsgMjtcbiAgICAgICAgcmVzdWx0IC09ICgyNSAqIG51bUFsaWduIC0gMTApICogbnVtQWxpZ24gLSA1NTtcbiAgICAgICAgaWYgKHZlciA+PSA3KVxuICAgICAgICAgIHJlc3VsdCAtPSAzNjtcbiAgICAgIH1cbiAgICAgIGFzc2VydCgyMDggPD0gcmVzdWx0ICYmIHJlc3VsdCA8PSAyOTY0OCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgOC1iaXQgZGF0YSAoaS5lLiBub3QgZXJyb3IgY29ycmVjdGlvbikgY29kZXdvcmRzIGNvbnRhaW5lZCBpbiBhbnlcbiAgICAvLyBRUiBDb2RlIG9mIHRoZSBnaXZlbiB2ZXJzaW9uIG51bWJlciBhbmQgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCwgd2l0aCByZW1haW5kZXIgYml0cyBkaXNjYXJkZWQuXG4gICAgLy8gVGhpcyBzdGF0ZWxlc3MgcHVyZSBmdW5jdGlvbiBjb3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBhICg0MCo0KS1jZWxsIGxvb2t1cCB0YWJsZS5cbiAgICBzdGF0aWMgZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXIsIGVjbCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoX1FyQ29kZS5nZXROdW1SYXdEYXRhTW9kdWxlcyh2ZXIpIC8gOCkgLSBfUXJDb2RlLkVDQ19DT0RFV09SRFNfUEVSX0JMT0NLW2VjbC5vcmRpbmFsXVt2ZXJdICogX1FyQ29kZS5OVU1fRVJST1JfQ09SUkVDVElPTl9CTE9DS1NbZWNsLm9yZGluYWxdW3Zlcl07XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBSZWVkLVNvbG9tb24gRUNDIGdlbmVyYXRvciBwb2x5bm9taWFsIGZvciB0aGUgZ2l2ZW4gZGVncmVlLiBUaGlzIGNvdWxkIGJlXG4gICAgLy8gaW1wbGVtZW50ZWQgYXMgYSBsb29rdXAgdGFibGUgb3ZlciBhbGwgcG9zc2libGUgcGFyYW1ldGVyIHZhbHVlcywgaW5zdGVhZCBvZiBhcyBhbiBhbGdvcml0aG0uXG4gICAgc3RhdGljIHJlZWRTb2xvbW9uQ29tcHV0ZURpdmlzb3IoZGVncmVlKSB7XG4gICAgICBpZiAoZGVncmVlIDwgMSB8fCBkZWdyZWUgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRGVncmVlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVncmVlIC0gMTsgaSsrKVxuICAgICAgICByZXN1bHQucHVzaCgwKTtcbiAgICAgIHJlc3VsdC5wdXNoKDEpO1xuICAgICAgbGV0IHJvb3QgPSAxO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWdyZWU7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHJlc3VsdFtqXSA9IF9RckNvZGUucmVlZFNvbG9tb25NdWx0aXBseShyZXN1bHRbal0sIHJvb3QpO1xuICAgICAgICAgIGlmIChqICsgMSA8IHJlc3VsdC5sZW5ndGgpXG4gICAgICAgICAgICByZXN1bHRbal0gXj0gcmVzdWx0W2ogKyAxXTtcbiAgICAgICAgfVxuICAgICAgICByb290ID0gX1FyQ29kZS5yZWVkU29sb21vbk11bHRpcGx5KHJvb3QsIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgUmVlZC1Tb2xvbW9uIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmQgZm9yIHRoZSBnaXZlbiBkYXRhIGFuZCBkaXZpc29yIHBvbHlub21pYWxzLlxuICAgIHN0YXRpYyByZWVkU29sb21vbkNvbXB1dGVSZW1haW5kZXIoZGF0YSwgZGl2aXNvcikge1xuICAgICAgbGV0IHJlc3VsdCA9IGRpdmlzb3IubWFwKChfKSA9PiAwKTtcbiAgICAgIGZvciAoY29uc3QgYiBvZiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IGIgXiByZXN1bHQuc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0LnB1c2goMCk7XG4gICAgICAgIGRpdmlzb3IuZm9yRWFjaCgoY29lZiwgaSkgPT4gcmVzdWx0W2ldIF49IF9RckNvZGUucmVlZFNvbG9tb25NdWx0aXBseShjb2VmLCBmYWN0b3IpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhlIHR3byBnaXZlbiBmaWVsZCBlbGVtZW50cyBtb2R1bG8gR0YoMl44LzB4MTFEKS4gVGhlIGFyZ3VtZW50cyBhbmQgcmVzdWx0XG4gICAgLy8gYXJlIHVuc2lnbmVkIDgtYml0IGludGVnZXJzLiBUaGlzIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIGEgbG9va3VwIHRhYmxlIG9mIDI1NioyNTYgZW50cmllcyBvZiB1aW50OC5cbiAgICBzdGF0aWMgcmVlZFNvbG9tb25NdWx0aXBseSh4LCB5KSB7XG4gICAgICBpZiAoeCA+Pj4gOCAhPSAwIHx8IHkgPj4+IDggIT0gMClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCeXRlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGxldCB6ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSA3OyBpID49IDA7IGktLSkge1xuICAgICAgICB6ID0geiA8PCAxIF4gKHogPj4+IDcpICogMjg1O1xuICAgICAgICB6IF49ICh5ID4+PiBpICYgMSkgKiB4O1xuICAgICAgfVxuICAgICAgYXNzZXJ0KHogPj4+IDggPT0gMCk7XG4gICAgICByZXR1cm4gejtcbiAgICB9XG4gICAgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGEgbGlnaHQgcnVuIGlzIGFkZGVkLCBhbmRcbiAgICAvLyByZXR1cm5zIGVpdGhlciAwLCAxLCBvciAyLiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0UGVuYWx0eVNjb3JlKCkuXG4gICAgZmluZGVyUGVuYWx0eUNvdW50UGF0dGVybnMocnVuSGlzdG9yeSkge1xuICAgICAgY29uc3QgbiA9IHJ1bkhpc3RvcnlbMV07XG4gICAgICBhc3NlcnQobiA8PSB0aGlzLnNpemUgKiAzKTtcbiAgICAgIGNvbnN0IGNvcmUgPSBuID4gMCAmJiBydW5IaXN0b3J5WzJdID09IG4gJiYgcnVuSGlzdG9yeVszXSA9PSBuICogMyAmJiBydW5IaXN0b3J5WzRdID09IG4gJiYgcnVuSGlzdG9yeVs1XSA9PSBuO1xuICAgICAgcmV0dXJuIChjb3JlICYmIHJ1bkhpc3RvcnlbMF0gPj0gbiAqIDQgJiYgcnVuSGlzdG9yeVs2XSA+PSBuID8gMSA6IDApICsgKGNvcmUgJiYgcnVuSGlzdG9yeVs2XSA+PSBuICogNCAmJiBydW5IaXN0b3J5WzBdID49IG4gPyAxIDogMCk7XG4gICAgfVxuICAgIC8vIE11c3QgYmUgY2FsbGVkIGF0IHRoZSBlbmQgb2YgYSBsaW5lIChyb3cgb3IgY29sdW1uKSBvZiBtb2R1bGVzLiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0UGVuYWx0eVNjb3JlKCkuXG4gICAgZmluZGVyUGVuYWx0eVRlcm1pbmF0ZUFuZENvdW50KGN1cnJlbnRSdW5Db2xvciwgY3VycmVudFJ1bkxlbmd0aCwgcnVuSGlzdG9yeSkge1xuICAgICAgaWYgKGN1cnJlbnRSdW5Db2xvcikge1xuICAgICAgICB0aGlzLmZpbmRlclBlbmFsdHlBZGRIaXN0b3J5KGN1cnJlbnRSdW5MZW5ndGgsIHJ1bkhpc3RvcnkpO1xuICAgICAgICBjdXJyZW50UnVuTGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRSdW5MZW5ndGggKz0gdGhpcy5zaXplO1xuICAgICAgdGhpcy5maW5kZXJQZW5hbHR5QWRkSGlzdG9yeShjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zKHJ1bkhpc3RvcnkpO1xuICAgIH1cbiAgICAvLyBQdXNoZXMgdGhlIGdpdmVuIHZhbHVlIHRvIHRoZSBmcm9udCBhbmQgZHJvcHMgdGhlIGxhc3QgdmFsdWUuIEEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXRQZW5hbHR5U2NvcmUoKS5cbiAgICBmaW5kZXJQZW5hbHR5QWRkSGlzdG9yeShjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KSB7XG4gICAgICBpZiAocnVuSGlzdG9yeVswXSA9PSAwKVxuICAgICAgICBjdXJyZW50UnVuTGVuZ3RoICs9IHRoaXMuc2l6ZTtcbiAgICAgIHJ1bkhpc3RvcnkucG9wKCk7XG4gICAgICBydW5IaXN0b3J5LnVuc2hpZnQoY3VycmVudFJ1bkxlbmd0aCk7XG4gICAgfVxuICB9O1xuICAvKi0tIENvbnN0YW50cyBhbmQgdGFibGVzIC0tKi9cbiAgLy8gVGhlIG1pbmltdW0gdmVyc2lvbiBudW1iZXIgc3VwcG9ydGVkIGluIHRoZSBRUiBDb2RlIE1vZGVsIDIgc3RhbmRhcmQuXG4gIF9RckNvZGUuTUlOX1ZFUlNJT04gPSAxO1xuICAvLyBUaGUgbWF4aW11bSB2ZXJzaW9uIG51bWJlciBzdXBwb3J0ZWQgaW4gdGhlIFFSIENvZGUgTW9kZWwgMiBzdGFuZGFyZC5cbiAgX1FyQ29kZS5NQVhfVkVSU0lPTiA9IDQwO1xuICAvLyBGb3IgdXNlIGluIGdldFBlbmFsdHlTY29yZSgpLCB3aGVuIGV2YWx1YXRpbmcgd2hpY2ggbWFzayBpcyBiZXN0LlxuICBfUXJDb2RlLlBFTkFMVFlfTjEgPSAzO1xuICBfUXJDb2RlLlBFTkFMVFlfTjIgPSAzO1xuICBfUXJDb2RlLlBFTkFMVFlfTjMgPSA0MDtcbiAgX1FyQ29kZS5QRU5BTFRZX040ID0gMTA7XG4gIF9RckNvZGUuRUNDX0NPREVXT1JEU19QRVJfQkxPQ0sgPSBbXG4gICAgLy8gVmVyc2lvbjogKG5vdGUgdGhhdCBpbmRleCAwIGlzIGZvciBwYWRkaW5nLCBhbmQgaXMgc2V0IHRvIGFuIGlsbGVnYWwgdmFsdWUpXG4gICAgLy8wLCAgMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LCAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIDMzLCAzNCwgMzUsIDM2LCAzNywgMzgsIDM5LCA0MCAgICBFcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gICAgWy0xLCA3LCAxMCwgMTUsIDIwLCAyNiwgMTgsIDIwLCAyNCwgMzAsIDE4LCAyMCwgMjQsIDI2LCAzMCwgMjIsIDI0LCAyOCwgMzAsIDI4LCAyOCwgMjgsIDI4LCAzMCwgMzAsIDI2LCAyOCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXSxcbiAgICAvLyBMb3dcbiAgICBbLTEsIDEwLCAxNiwgMjYsIDE4LCAyNCwgMTYsIDE4LCAyMiwgMjIsIDI2LCAzMCwgMjIsIDIyLCAyNCwgMjQsIDI4LCAyOCwgMjYsIDI2LCAyNiwgMjYsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4XSxcbiAgICAvLyBNZWRpdW1cbiAgICBbLTEsIDEzLCAyMiwgMTgsIDI2LCAxOCwgMjQsIDE4LCAyMiwgMjAsIDI0LCAyOCwgMjYsIDI0LCAyMCwgMzAsIDI0LCAyOCwgMjgsIDI2LCAzMCwgMjgsIDMwLCAzMCwgMzAsIDMwLCAyOCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXSxcbiAgICAvLyBRdWFydGlsZVxuICAgIFstMSwgMTcsIDI4LCAyMiwgMTYsIDIyLCAyOCwgMjYsIDI2LCAyNCwgMjgsIDI0LCAyOCwgMjIsIDI0LCAyNCwgMzAsIDI4LCAyOCwgMjYsIDI4LCAzMCwgMjQsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzBdXG4gICAgLy8gSGlnaFxuICBdO1xuICBfUXJDb2RlLk5VTV9FUlJPUl9DT1JSRUNUSU9OX0JMT0NLUyA9IFtcbiAgICAvLyBWZXJzaW9uOiAobm90ZSB0aGF0IGluZGV4IDAgaXMgZm9yIHBhZGRpbmcsIGFuZCBpcyBzZXQgdG8gYW4gaWxsZWdhbCB2YWx1ZSlcbiAgICAvLzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDAgICAgRXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuICAgIFstMSwgMSwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgNCwgNCwgNCwgNCwgNCwgNiwgNiwgNiwgNiwgNywgOCwgOCwgOSwgOSwgMTAsIDEyLCAxMiwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAxOSwgMjAsIDIxLCAyMiwgMjQsIDI1XSxcbiAgICAvLyBMb3dcbiAgICBbLTEsIDEsIDEsIDEsIDIsIDIsIDQsIDQsIDQsIDUsIDUsIDUsIDgsIDksIDksIDEwLCAxMCwgMTEsIDEzLCAxNCwgMTYsIDE3LCAxNywgMTgsIDIwLCAyMSwgMjMsIDI1LCAyNiwgMjgsIDI5LCAzMSwgMzMsIDM1LCAzNywgMzgsIDQwLCA0MywgNDUsIDQ3LCA0OV0sXG4gICAgLy8gTWVkaXVtXG4gICAgWy0xLCAxLCAxLCAyLCAyLCA0LCA0LCA2LCA2LCA4LCA4LCA4LCAxMCwgMTIsIDE2LCAxMiwgMTcsIDE2LCAxOCwgMjEsIDIwLCAyMywgMjMsIDI1LCAyNywgMjksIDM0LCAzNCwgMzUsIDM4LCA0MCwgNDMsIDQ1LCA0OCwgNTEsIDUzLCA1NiwgNTksIDYyLCA2NSwgNjhdLFxuICAgIC8vIFF1YXJ0aWxlXG4gICAgWy0xLCAxLCAxLCAyLCA0LCA0LCA0LCA1LCA2LCA4LCA4LCAxMSwgMTEsIDE2LCAxNiwgMTgsIDE2LCAxOSwgMjEsIDI1LCAyNSwgMjUsIDM0LCAzMCwgMzIsIDM1LCAzNywgNDAsIDQyLCA0NSwgNDgsIDUxLCA1NCwgNTcsIDYwLCA2MywgNjYsIDcwLCA3NCwgNzcsIDgxXVxuICAgIC8vIEhpZ2hcbiAgXTtcbiAgbGV0IFFyQ29kZSA9IF9RckNvZGU7XG4gIHFyY29kZWdlbjIuUXJDb2RlID0gX1FyQ29kZTtcbiAgZnVuY3Rpb24gYXBwZW5kQml0cyh2YWwsIGxlbiwgYmIpIHtcbiAgICBpZiAobGVuIDwgMCB8fCBsZW4gPiAzMSB8fCB2YWwgPj4+IGxlbiAhPSAwKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJWYWx1ZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgZm9yIChsZXQgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgYmIucHVzaCh2YWwgPj4+IGkgJiAxKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRCaXQoeCwgaSkge1xuICAgIHJldHVybiAoeCA+Pj4gaSAmIDEpICE9IDA7XG4gIH1cbiAgZnVuY3Rpb24gYXNzZXJ0KGNvbmQpIHtcbiAgICBpZiAoIWNvbmQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gZXJyb3JcIik7XG4gIH1cbiAgY29uc3QgX1FyU2VnbWVudCA9IGNsYXNzIF9RclNlZ21lbnQge1xuICAgIC8qLS0gQ29uc3RydWN0b3IgKGxvdyBsZXZlbCkgYW5kIGZpZWxkcyAtLSovXG4gICAgLy8gQ3JlYXRlcyBhIG5ldyBRUiBDb2RlIHNlZ21lbnQgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBhbmQgZGF0YS5cbiAgICAvLyBUaGUgY2hhcmFjdGVyIGNvdW50IChudW1DaGFycykgbXVzdCBhZ3JlZSB3aXRoIHRoZSBtb2RlIGFuZCB0aGUgYml0IGJ1ZmZlciBsZW5ndGgsXG4gICAgLy8gYnV0IHRoZSBjb25zdHJhaW50IGlzbid0IGNoZWNrZWQuIFRoZSBnaXZlbiBiaXQgYnVmZmVyIGlzIGNsb25lZCBhbmQgc3RvcmVkLlxuICAgIGNvbnN0cnVjdG9yKG1vZGUsIG51bUNoYXJzLCBiaXREYXRhKSB7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5udW1DaGFycyA9IG51bUNoYXJzO1xuICAgICAgdGhpcy5iaXREYXRhID0gYml0RGF0YTtcbiAgICAgIGlmIChudW1DaGFycyA8IDApXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcbiAgICAgIHRoaXMuYml0RGF0YSA9IGJpdERhdGEuc2xpY2UoKTtcbiAgICB9XG4gICAgLyotLSBTdGF0aWMgZmFjdG9yeSBmdW5jdGlvbnMgKG1pZCBsZXZlbCkgLS0qL1xuICAgIC8vIFJldHVybnMgYSBzZWdtZW50IHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gYmluYXJ5IGRhdGEgZW5jb2RlZCBpblxuICAgIC8vIGJ5dGUgbW9kZS4gQWxsIGlucHV0IGJ5dGUgYXJyYXlzIGFyZSBhY2NlcHRhYmxlLiBBbnkgdGV4dCBzdHJpbmdcbiAgICAvLyBjYW4gYmUgY29udmVydGVkIHRvIFVURi04IGJ5dGVzIGFuZCBlbmNvZGVkIGFzIGEgYnl0ZSBtb2RlIHNlZ21lbnQuXG4gICAgc3RhdGljIG1ha2VCeXRlcyhkYXRhKSB7XG4gICAgICBsZXQgYmIgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgYiBvZiBkYXRhKVxuICAgICAgICBhcHBlbmRCaXRzKGIsIDgsIGJiKTtcbiAgICAgIHJldHVybiBuZXcgX1FyU2VnbWVudChfUXJTZWdtZW50Lk1vZGUuQllURSwgZGF0YS5sZW5ndGgsIGJiKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIHNlZ21lbnQgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBzdHJpbmcgb2YgZGVjaW1hbCBkaWdpdHMgZW5jb2RlZCBpbiBudW1lcmljIG1vZGUuXG4gICAgc3RhdGljIG1ha2VOdW1lcmljKGRpZ2l0cykge1xuICAgICAgaWYgKCFfUXJTZWdtZW50LmlzTnVtZXJpYyhkaWdpdHMpKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlN0cmluZyBjb250YWlucyBub24tbnVtZXJpYyBjaGFyYWN0ZXJzXCIpO1xuICAgICAgbGV0IGJiID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZ2l0cy5sZW5ndGg7ICkge1xuICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oZGlnaXRzLmxlbmd0aCAtIGksIDMpO1xuICAgICAgICBhcHBlbmRCaXRzKHBhcnNlSW50KGRpZ2l0cy5zdWJzdHJpbmcoaSwgaSArIG4pLCAxMCksIG4gKiAzICsgMSwgYmIpO1xuICAgICAgICBpICs9IG47XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IF9RclNlZ21lbnQoX1FyU2VnbWVudC5Nb2RlLk5VTUVSSUMsIGRpZ2l0cy5sZW5ndGgsIGJiKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIHNlZ21lbnQgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB0ZXh0IHN0cmluZyBlbmNvZGVkIGluIGFscGhhbnVtZXJpYyBtb2RlLlxuICAgIC8vIFRoZSBjaGFyYWN0ZXJzIGFsbG93ZWQgYXJlOiAwIHRvIDksIEEgdG8gWiAodXBwZXJjYXNlIG9ubHkpLCBzcGFjZSxcbiAgICAvLyBkb2xsYXIsIHBlcmNlbnQsIGFzdGVyaXNrLCBwbHVzLCBoeXBoZW4sIHBlcmlvZCwgc2xhc2gsIGNvbG9uLlxuICAgIHN0YXRpYyBtYWtlQWxwaGFudW1lcmljKHRleHQpIHtcbiAgICAgIGlmICghX1FyU2VnbWVudC5pc0FscGhhbnVtZXJpYyh0ZXh0KSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTdHJpbmcgY29udGFpbnMgdW5lbmNvZGFibGUgY2hhcmFjdGVycyBpbiBhbHBoYW51bWVyaWMgbW9kZVwiKTtcbiAgICAgIGxldCBiYiA9IFtdO1xuICAgICAgbGV0IGk7XG4gICAgICBmb3IgKGkgPSAwOyBpICsgMiA8PSB0ZXh0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGxldCB0ZW1wID0gX1FyU2VnbWVudC5BTFBIQU5VTUVSSUNfQ0hBUlNFVC5pbmRleE9mKHRleHQuY2hhckF0KGkpKSAqIDQ1O1xuICAgICAgICB0ZW1wICs9IF9RclNlZ21lbnQuQUxQSEFOVU1FUklDX0NIQVJTRVQuaW5kZXhPZih0ZXh0LmNoYXJBdChpICsgMSkpO1xuICAgICAgICBhcHBlbmRCaXRzKHRlbXAsIDExLCBiYik7XG4gICAgICB9XG4gICAgICBpZiAoaSA8IHRleHQubGVuZ3RoKVxuICAgICAgICBhcHBlbmRCaXRzKF9RclNlZ21lbnQuQUxQSEFOVU1FUklDX0NIQVJTRVQuaW5kZXhPZih0ZXh0LmNoYXJBdChpKSksIDYsIGJiKTtcbiAgICAgIHJldHVybiBuZXcgX1FyU2VnbWVudChfUXJTZWdtZW50Lk1vZGUuQUxQSEFOVU1FUklDLCB0ZXh0Lmxlbmd0aCwgYmIpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgbmV3IG11dGFibGUgbGlzdCBvZiB6ZXJvIG9yIG1vcmUgc2VnbWVudHMgdG8gcmVwcmVzZW50IHRoZSBnaXZlbiBVbmljb2RlIHRleHQgc3RyaW5nLlxuICAgIC8vIFRoZSByZXN1bHQgbWF5IHVzZSB2YXJpb3VzIHNlZ21lbnQgbW9kZXMgYW5kIHN3aXRjaCBtb2RlcyB0byBvcHRpbWl6ZSB0aGUgbGVuZ3RoIG9mIHRoZSBiaXQgc3RyZWFtLlxuICAgIHN0YXRpYyBtYWtlU2VnbWVudHModGV4dCkge1xuICAgICAgaWYgKHRleHQgPT0gXCJcIilcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgZWxzZSBpZiAoX1FyU2VnbWVudC5pc051bWVyaWModGV4dCkpXG4gICAgICAgIHJldHVybiBbX1FyU2VnbWVudC5tYWtlTnVtZXJpYyh0ZXh0KV07XG4gICAgICBlbHNlIGlmIChfUXJTZWdtZW50LmlzQWxwaGFudW1lcmljKHRleHQpKVxuICAgICAgICByZXR1cm4gW19RclNlZ21lbnQubWFrZUFscGhhbnVtZXJpYyh0ZXh0KV07XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBbX1FyU2VnbWVudC5tYWtlQnl0ZXMoX1FyU2VnbWVudC50b1V0ZjhCeXRlQXJyYXkodGV4dCkpXTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIHNlZ21lbnQgcmVwcmVzZW50aW5nIGFuIEV4dGVuZGVkIENoYW5uZWwgSW50ZXJwcmV0YXRpb25cbiAgICAvLyAoRUNJKSBkZXNpZ25hdG9yIHdpdGggdGhlIGdpdmVuIGFzc2lnbm1lbnQgdmFsdWUuXG4gICAgc3RhdGljIG1ha2VFY2koYXNzaWduVmFsKSB7XG4gICAgICBsZXQgYmIgPSBbXTtcbiAgICAgIGlmIChhc3NpZ25WYWwgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVDSSBhc3NpZ25tZW50IHZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGVsc2UgaWYgKGFzc2lnblZhbCA8IDEgPDwgNylcbiAgICAgICAgYXBwZW5kQml0cyhhc3NpZ25WYWwsIDgsIGJiKTtcbiAgICAgIGVsc2UgaWYgKGFzc2lnblZhbCA8IDEgPDwgMTQpIHtcbiAgICAgICAgYXBwZW5kQml0cygyLCAyLCBiYik7XG4gICAgICAgIGFwcGVuZEJpdHMoYXNzaWduVmFsLCAxNCwgYmIpO1xuICAgICAgfSBlbHNlIGlmIChhc3NpZ25WYWwgPCAxZTYpIHtcbiAgICAgICAgYXBwZW5kQml0cyg2LCAzLCBiYik7XG4gICAgICAgIGFwcGVuZEJpdHMoYXNzaWduVmFsLCAyMSwgYmIpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRUNJIGFzc2lnbm1lbnQgdmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgcmV0dXJuIG5ldyBfUXJTZWdtZW50KF9RclNlZ21lbnQuTW9kZS5FQ0ksIDAsIGJiKTtcbiAgICB9XG4gICAgLy8gVGVzdHMgd2hldGhlciB0aGUgZ2l2ZW4gc3RyaW5nIGNhbiBiZSBlbmNvZGVkIGFzIGEgc2VnbWVudCBpbiBudW1lcmljIG1vZGUuXG4gICAgLy8gQSBzdHJpbmcgaXMgZW5jb2RhYmxlIGlmZiBlYWNoIGNoYXJhY3RlciBpcyBpbiB0aGUgcmFuZ2UgMCB0byA5LlxuICAgIHN0YXRpYyBpc051bWVyaWModGV4dCkge1xuICAgICAgcmV0dXJuIF9RclNlZ21lbnQuTlVNRVJJQ19SRUdFWC50ZXN0KHRleHQpO1xuICAgIH1cbiAgICAvLyBUZXN0cyB3aGV0aGVyIHRoZSBnaXZlbiBzdHJpbmcgY2FuIGJlIGVuY29kZWQgYXMgYSBzZWdtZW50IGluIGFscGhhbnVtZXJpYyBtb2RlLlxuICAgIC8vIEEgc3RyaW5nIGlzIGVuY29kYWJsZSBpZmYgZWFjaCBjaGFyYWN0ZXIgaXMgaW4gdGhlIGZvbGxvd2luZyBzZXQ6IDAgdG8gOSwgQSB0byBaXG4gICAgLy8gKHVwcGVyY2FzZSBvbmx5KSwgc3BhY2UsIGRvbGxhciwgcGVyY2VudCwgYXN0ZXJpc2ssIHBsdXMsIGh5cGhlbiwgcGVyaW9kLCBzbGFzaCwgY29sb24uXG4gICAgc3RhdGljIGlzQWxwaGFudW1lcmljKHRleHQpIHtcbiAgICAgIHJldHVybiBfUXJTZWdtZW50LkFMUEhBTlVNRVJJQ19SRUdFWC50ZXN0KHRleHQpO1xuICAgIH1cbiAgICAvKi0tIE1ldGhvZHMgLS0qL1xuICAgIC8vIFJldHVybnMgYSBuZXcgY29weSBvZiB0aGUgZGF0YSBiaXRzIG9mIHRoaXMgc2VnbWVudC5cbiAgICBnZXREYXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYml0RGF0YS5zbGljZSgpO1xuICAgIH1cbiAgICAvLyAoUGFja2FnZS1wcml2YXRlKSBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gZW5jb2RlIHRoZSBnaXZlbiBzZWdtZW50cyBhdFxuICAgIC8vIHRoZSBnaXZlbiB2ZXJzaW9uLiBUaGUgcmVzdWx0IGlzIGluZmluaXR5IGlmIGEgc2VnbWVudCBoYXMgdG9vIG1hbnkgY2hhcmFjdGVycyB0byBmaXQgaXRzIGxlbmd0aCBmaWVsZC5cbiAgICBzdGF0aWMgZ2V0VG90YWxCaXRzKHNlZ3MsIHZlcnNpb24pIHtcbiAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2Vncykge1xuICAgICAgICBjb25zdCBjY2JpdHMgPSBzZWcubW9kZS5udW1DaGFyQ291bnRCaXRzKHZlcnNpb24pO1xuICAgICAgICBpZiAoc2VnLm51bUNoYXJzID49IDEgPDwgY2NiaXRzKVxuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgcmVzdWx0ICs9IDQgKyBjY2JpdHMgKyBzZWcuYml0RGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gc3RyaW5nIGVuY29kZWQgaW4gVVRGLTguXG4gICAgc3RhdGljIHRvVXRmOEJ5dGVBcnJheShzdHIpIHtcbiAgICAgIHN0ciA9IGVuY29kZVVSSShzdHIpO1xuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoaSkgIT0gXCIlXCIpXG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzdHIuc3Vic3RyaW5nKGkgKyAxLCBpICsgMyksIDE2KSk7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbiAgLyotLSBDb25zdGFudHMgLS0qL1xuICAvLyBEZXNjcmliZXMgcHJlY2lzZWx5IGFsbCBzdHJpbmdzIHRoYXQgYXJlIGVuY29kYWJsZSBpbiBudW1lcmljIG1vZGUuXG4gIF9RclNlZ21lbnQuTlVNRVJJQ19SRUdFWCA9IC9eWzAtOV0qJC87XG4gIC8vIERlc2NyaWJlcyBwcmVjaXNlbHkgYWxsIHN0cmluZ3MgdGhhdCBhcmUgZW5jb2RhYmxlIGluIGFscGhhbnVtZXJpYyBtb2RlLlxuICBfUXJTZWdtZW50LkFMUEhBTlVNRVJJQ19SRUdFWCA9IC9eW0EtWjAtOSAkJSorLlxcLzotXSokLztcbiAgLy8gVGhlIHNldCBvZiBhbGwgbGVnYWwgY2hhcmFjdGVycyBpbiBhbHBoYW51bWVyaWMgbW9kZSxcbiAgLy8gd2hlcmUgZWFjaCBjaGFyYWN0ZXIgdmFsdWUgbWFwcyB0byB0aGUgaW5kZXggaW4gdGhlIHN0cmluZy5cbiAgX1FyU2VnbWVudC5BTFBIQU5VTUVSSUNfQ0hBUlNFVCA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaICQlKistLi86XCI7XG4gIGxldCBRclNlZ21lbnQgPSBfUXJTZWdtZW50O1xuICBxcmNvZGVnZW4yLlFyU2VnbWVudCA9IF9RclNlZ21lbnQ7XG59KShxcmNvZGVnZW4gfHwgKHFyY29kZWdlbiA9IHt9KSk7XG4oKHFyY29kZWdlbjIpID0+IHtcbiAgbGV0IFFyQ29kZTtcbiAgKChRckNvZGUyKSA9PiB7XG4gICAgY29uc3QgX0VjYyA9IGNsYXNzIF9FY2Mge1xuICAgICAgLy8gVGhlIFFSIENvZGUgY2FuIHRvbGVyYXRlIGFib3V0IDMwJSBlcnJvbmVvdXMgY29kZXdvcmRzXG4gICAgICAvKi0tIENvbnN0cnVjdG9yIGFuZCBmaWVsZHMgLS0qL1xuICAgICAgY29uc3RydWN0b3Iob3JkaW5hbCwgZm9ybWF0Qml0cykge1xuICAgICAgICB0aGlzLm9yZGluYWwgPSBvcmRpbmFsO1xuICAgICAgICB0aGlzLmZvcm1hdEJpdHMgPSBmb3JtYXRCaXRzO1xuICAgICAgfVxuICAgIH07XG4gICAgLyotLSBDb25zdGFudHMgLS0qL1xuICAgIF9FY2MuTE9XID0gbmV3IF9FY2MoMCwgMSk7XG4gICAgLy8gVGhlIFFSIENvZGUgY2FuIHRvbGVyYXRlIGFib3V0ICA3JSBlcnJvbmVvdXMgY29kZXdvcmRzXG4gICAgX0VjYy5NRURJVU0gPSBuZXcgX0VjYygxLCAwKTtcbiAgICAvLyBUaGUgUVIgQ29kZSBjYW4gdG9sZXJhdGUgYWJvdXQgMTUlIGVycm9uZW91cyBjb2Rld29yZHNcbiAgICBfRWNjLlFVQVJUSUxFID0gbmV3IF9FY2MoMiwgMyk7XG4gICAgLy8gVGhlIFFSIENvZGUgY2FuIHRvbGVyYXRlIGFib3V0IDI1JSBlcnJvbmVvdXMgY29kZXdvcmRzXG4gICAgX0VjYy5ISUdIID0gbmV3IF9FY2MoMywgMik7XG4gICAgbGV0IEVjYyA9IF9FY2M7XG4gICAgUXJDb2RlMi5FY2MgPSBfRWNjO1xuICB9KShRckNvZGUgPSBxcmNvZGVnZW4yLlFyQ29kZSB8fCAocXJjb2RlZ2VuMi5RckNvZGUgPSB7fSkpO1xufSkocXJjb2RlZ2VuIHx8IChxcmNvZGVnZW4gPSB7fSkpO1xuKChxcmNvZGVnZW4yKSA9PiB7XG4gIGxldCBRclNlZ21lbnQ7XG4gICgoUXJTZWdtZW50MikgPT4ge1xuICAgIGNvbnN0IF9Nb2RlID0gY2xhc3MgX01vZGUge1xuICAgICAgLyotLSBDb25zdHJ1Y3RvciBhbmQgZmllbGRzIC0tKi9cbiAgICAgIGNvbnN0cnVjdG9yKG1vZGVCaXRzLCBudW1CaXRzQ2hhckNvdW50KSB7XG4gICAgICAgIHRoaXMubW9kZUJpdHMgPSBtb2RlQml0cztcbiAgICAgICAgdGhpcy5udW1CaXRzQ2hhckNvdW50ID0gbnVtQml0c0NoYXJDb3VudDtcbiAgICAgIH1cbiAgICAgIC8qLS0gTWV0aG9kIC0tKi9cbiAgICAgIC8vIChQYWNrYWdlLXByaXZhdGUpIFJldHVybnMgdGhlIGJpdCB3aWR0aCBvZiB0aGUgY2hhcmFjdGVyIGNvdW50IGZpZWxkIGZvciBhIHNlZ21lbnQgaW5cbiAgICAgIC8vIHRoaXMgbW9kZSBpbiBhIFFSIENvZGUgYXQgdGhlIGdpdmVuIHZlcnNpb24gbnVtYmVyLiBUaGUgcmVzdWx0IGlzIGluIHRoZSByYW5nZSBbMCwgMTZdLlxuICAgICAgbnVtQ2hhckNvdW50Qml0cyh2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtQml0c0NoYXJDb3VudFtNYXRoLmZsb29yKCh2ZXIgKyA3KSAvIDE3KV07XG4gICAgICB9XG4gICAgfTtcbiAgICAvKi0tIENvbnN0YW50cyAtLSovXG4gICAgX01vZGUuTlVNRVJJQyA9IG5ldyBfTW9kZSgxLCBbMTAsIDEyLCAxNF0pO1xuICAgIF9Nb2RlLkFMUEhBTlVNRVJJQyA9IG5ldyBfTW9kZSgyLCBbOSwgMTEsIDEzXSk7XG4gICAgX01vZGUuQllURSA9IG5ldyBfTW9kZSg0LCBbOCwgMTYsIDE2XSk7XG4gICAgX01vZGUuS0FOSkkgPSBuZXcgX01vZGUoOCwgWzgsIDEwLCAxMl0pO1xuICAgIF9Nb2RlLkVDSSA9IG5ldyBfTW9kZSg3LCBbMCwgMCwgMF0pO1xuICAgIGxldCBNb2RlID0gX01vZGU7XG4gICAgUXJTZWdtZW50Mi5Nb2RlID0gX01vZGU7XG4gIH0pKFFyU2VnbWVudCA9IHFyY29kZWdlbjIuUXJTZWdtZW50IHx8IChxcmNvZGVnZW4yLlFyU2VnbWVudCA9IHt9KSk7XG59KShxcmNvZGVnZW4gfHwgKHFyY29kZWdlbiA9IHt9KSk7XG52YXIgcXJjb2RlZ2VuX2RlZmF1bHQgPSBxcmNvZGVnZW47XG5cbi8vIHNyYy9pbmRleC50c3hcbi8qKlxuICogQGxpY2Vuc2UgcXJjb2RlLnJlYWN0XG4gKiBDb3B5cmlnaHQgKGMpIFBhdWwgTydTaGFubmVzc3lcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBJU0NcbiAqL1xudmFyIEVSUk9SX0xFVkVMX01BUCA9IHtcbiAgTDogcXJjb2RlZ2VuX2RlZmF1bHQuUXJDb2RlLkVjYy5MT1csXG4gIE06IHFyY29kZWdlbl9kZWZhdWx0LlFyQ29kZS5FY2MuTUVESVVNLFxuICBROiBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuRWNjLlFVQVJUSUxFLFxuICBIOiBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuRWNjLkhJR0hcbn07XG52YXIgREVGQVVMVF9TSVpFID0gMTI4O1xudmFyIERFRkFVTFRfTEVWRUwgPSBcIkxcIjtcbnZhciBERUZBVUxUX0JHQ09MT1IgPSBcIiNGRkZGRkZcIjtcbnZhciBERUZBVUxUX0ZHQ09MT1IgPSBcIiMwMDAwMDBcIjtcbnZhciBERUZBVUxUX0lOQ0xVREVNQVJHSU4gPSBmYWxzZTtcbnZhciBERUZBVUxUX01JTlZFUlNJT04gPSAxO1xudmFyIFNQRUNfTUFSR0lOX1NJWkUgPSA0O1xudmFyIERFRkFVTFRfTUFSR0lOX1NJWkUgPSAwO1xudmFyIERFRkFVTFRfSU1HX1NDQUxFID0gMC4xO1xuZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKG1vZHVsZXMsIG1hcmdpbiA9IDApIHtcbiAgY29uc3Qgb3BzID0gW107XG4gIG1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihyb3csIHkpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsO1xuICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIHgpIHtcbiAgICAgIGlmICghY2VsbCAmJiBzdGFydCAhPT0gbnVsbCkge1xuICAgICAgICBvcHMucHVzaChcbiAgICAgICAgICBgTSR7c3RhcnQgKyBtYXJnaW59ICR7eSArIG1hcmdpbn1oJHt4IC0gc3RhcnR9djFIJHtzdGFydCArIG1hcmdpbn16YFxuICAgICAgICApO1xuICAgICAgICBzdGFydCA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh4ID09PSByb3cubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgb3BzLnB1c2goYE0ke3ggKyBtYXJnaW59LCR7eSArIG1hcmdpbn0gaDF2MUgke3ggKyBtYXJnaW59emApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wcy5wdXNoKFxuICAgICAgICAgICAgYE0ke3N0YXJ0ICsgbWFyZ2lufSwke3kgKyBtYXJnaW59IGgke3ggKyAxIC0gc3RhcnR9djFIJHtzdGFydCArIG1hcmdpbn16YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNlbGwgJiYgc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgc3RhcnQgPSB4O1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9wcy5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZXhjYXZhdGVNb2R1bGVzKG1vZHVsZXMsIGV4Y2F2YXRpb24pIHtcbiAgcmV0dXJuIG1vZHVsZXMuc2xpY2UoKS5tYXAoKHJvdywgeSkgPT4ge1xuICAgIGlmICh5IDwgZXhjYXZhdGlvbi55IHx8IHkgPj0gZXhjYXZhdGlvbi55ICsgZXhjYXZhdGlvbi5oKSB7XG4gICAgICByZXR1cm4gcm93O1xuICAgIH1cbiAgICByZXR1cm4gcm93Lm1hcCgoY2VsbCwgeCkgPT4ge1xuICAgICAgaWYgKHggPCBleGNhdmF0aW9uLnggfHwgeCA+PSBleGNhdmF0aW9uLnggKyBleGNhdmF0aW9uLncpIHtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0SW1hZ2VTZXR0aW5ncyhjZWxscywgc2l6ZSwgbWFyZ2luLCBpbWFnZVNldHRpbmdzKSB7XG4gIGlmIChpbWFnZVNldHRpbmdzID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBudW1DZWxscyA9IGNlbGxzLmxlbmd0aCArIG1hcmdpbiAqIDI7XG4gIGNvbnN0IGRlZmF1bHRTaXplID0gTWF0aC5mbG9vcihzaXplICogREVGQVVMVF9JTUdfU0NBTEUpO1xuICBjb25zdCBzY2FsZSA9IG51bUNlbGxzIC8gc2l6ZTtcbiAgY29uc3QgdyA9IChpbWFnZVNldHRpbmdzLndpZHRoIHx8IGRlZmF1bHRTaXplKSAqIHNjYWxlO1xuICBjb25zdCBoID0gKGltYWdlU2V0dGluZ3MuaGVpZ2h0IHx8IGRlZmF1bHRTaXplKSAqIHNjYWxlO1xuICBjb25zdCB4ID0gaW1hZ2VTZXR0aW5ncy54ID09IG51bGwgPyBjZWxscy5sZW5ndGggLyAyIC0gdyAvIDIgOiBpbWFnZVNldHRpbmdzLnggKiBzY2FsZTtcbiAgY29uc3QgeSA9IGltYWdlU2V0dGluZ3MueSA9PSBudWxsID8gY2VsbHMubGVuZ3RoIC8gMiAtIGggLyAyIDogaW1hZ2VTZXR0aW5ncy55ICogc2NhbGU7XG4gIGNvbnN0IG9wYWNpdHkgPSBpbWFnZVNldHRpbmdzLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBpbWFnZVNldHRpbmdzLm9wYWNpdHk7XG4gIGxldCBleGNhdmF0aW9uID0gbnVsbDtcbiAgaWYgKGltYWdlU2V0dGluZ3MuZXhjYXZhdGUpIHtcbiAgICBsZXQgZmxvb3JYID0gTWF0aC5mbG9vcih4KTtcbiAgICBsZXQgZmxvb3JZID0gTWF0aC5mbG9vcih5KTtcbiAgICBsZXQgY2VpbFcgPSBNYXRoLmNlaWwodyArIHggLSBmbG9vclgpO1xuICAgIGxldCBjZWlsSCA9IE1hdGguY2VpbChoICsgeSAtIGZsb29yWSk7XG4gICAgZXhjYXZhdGlvbiA9IHsgeDogZmxvb3JYLCB5OiBmbG9vclksIHc6IGNlaWxXLCBoOiBjZWlsSCB9O1xuICB9XG4gIGNvbnN0IGNyb3NzT3JpZ2luID0gaW1hZ2VTZXR0aW5ncy5jcm9zc09yaWdpbjtcbiAgcmV0dXJuIHsgeCwgeSwgaCwgdywgZXhjYXZhdGlvbiwgb3BhY2l0eSwgY3Jvc3NPcmlnaW4gfTtcbn1cbmZ1bmN0aW9uIGdldE1hcmdpblNpemUoaW5jbHVkZU1hcmdpbiwgbWFyZ2luU2l6ZSkge1xuICBpZiAobWFyZ2luU2l6ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGguZmxvb3IobWFyZ2luU2l6ZSksIDApO1xuICB9XG4gIHJldHVybiBpbmNsdWRlTWFyZ2luID8gU1BFQ19NQVJHSU5fU0laRSA6IERFRkFVTFRfTUFSR0lOX1NJWkU7XG59XG5mdW5jdGlvbiB1c2VRUkNvZGUoe1xuICB2YWx1ZSxcbiAgbGV2ZWwsXG4gIG1pblZlcnNpb24sXG4gIGluY2x1ZGVNYXJnaW4sXG4gIG1hcmdpblNpemUsXG4gIGltYWdlU2V0dGluZ3MsXG4gIHNpemUsXG4gIGJvb3N0TGV2ZWxcbn0pIHtcbiAgbGV0IHFyY29kZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdmFsdWVzLnJlZHVjZSgoYWNjdW0sIHYpID0+IHtcbiAgICAgIGFjY3VtLnB1c2goLi4ucXJjb2RlZ2VuX2RlZmF1bHQuUXJTZWdtZW50Lm1ha2VTZWdtZW50cyh2KSk7XG4gICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuZW5jb2RlU2VnbWVudHMoXG4gICAgICBzZWdtZW50cyxcbiAgICAgIEVSUk9SX0xFVkVMX01BUFtsZXZlbF0sXG4gICAgICBtaW5WZXJzaW9uLFxuICAgICAgdm9pZCAwLFxuICAgICAgdm9pZCAwLFxuICAgICAgYm9vc3RMZXZlbFxuICAgICk7XG4gIH0sIFt2YWx1ZSwgbGV2ZWwsIG1pblZlcnNpb24sIGJvb3N0TGV2ZWxdKTtcbiAgY29uc3QgeyBjZWxscywgbWFyZ2luLCBudW1DZWxscywgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MgfSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBjZWxsczIgPSBxcmNvZGUuZ2V0TW9kdWxlcygpO1xuICAgIGNvbnN0IG1hcmdpbjIgPSBnZXRNYXJnaW5TaXplKGluY2x1ZGVNYXJnaW4sIG1hcmdpblNpemUpO1xuICAgIGNvbnN0IG51bUNlbGxzMiA9IGNlbGxzMi5sZW5ndGggKyBtYXJnaW4yICogMjtcbiAgICBjb25zdCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5nczIgPSBnZXRJbWFnZVNldHRpbmdzKFxuICAgICAgY2VsbHMyLFxuICAgICAgc2l6ZSxcbiAgICAgIG1hcmdpbjIsXG4gICAgICBpbWFnZVNldHRpbmdzXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2VsbHM6IGNlbGxzMixcbiAgICAgIG1hcmdpbjogbWFyZ2luMixcbiAgICAgIG51bUNlbGxzOiBudW1DZWxsczIsXG4gICAgICBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5nczogY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MyXG4gICAgfTtcbiAgfSwgW3FyY29kZSwgc2l6ZSwgaW1hZ2VTZXR0aW5ncywgaW5jbHVkZU1hcmdpbiwgbWFyZ2luU2l6ZV0pO1xuICByZXR1cm4ge1xuICAgIHFyY29kZSxcbiAgICBtYXJnaW4sXG4gICAgY2VsbHMsXG4gICAgbnVtQ2VsbHMsXG4gICAgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3NcbiAgfTtcbn1cbnZhciBTVVBQT1JUU19QQVRIMkQgPSBmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBuZXcgUGF0aDJEKCkuYWRkUGF0aChuZXcgUGF0aDJEKCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufSgpO1xudmFyIFFSQ29kZUNhbnZhcyA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIGZ1bmN0aW9uIFFSQ29kZUNhbnZhczIocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICAgIGNvbnN0IF9hID0gcHJvcHMsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgc2l6ZSA9IERFRkFVTFRfU0laRSxcbiAgICAgIGxldmVsID0gREVGQVVMVF9MRVZFTCxcbiAgICAgIGJnQ29sb3IgPSBERUZBVUxUX0JHQ09MT1IsXG4gICAgICBmZ0NvbG9yID0gREVGQVVMVF9GR0NPTE9SLFxuICAgICAgaW5jbHVkZU1hcmdpbiA9IERFRkFVTFRfSU5DTFVERU1BUkdJTixcbiAgICAgIG1pblZlcnNpb24gPSBERUZBVUxUX01JTlZFUlNJT04sXG4gICAgICBib29zdExldmVsLFxuICAgICAgbWFyZ2luU2l6ZSxcbiAgICAgIGltYWdlU2V0dGluZ3NcbiAgICB9ID0gX2EsIGV4dHJhUHJvcHMgPSBfX29ialJlc3QoX2EsIFtcbiAgICAgIFwidmFsdWVcIixcbiAgICAgIFwic2l6ZVwiLFxuICAgICAgXCJsZXZlbFwiLFxuICAgICAgXCJiZ0NvbG9yXCIsXG4gICAgICBcImZnQ29sb3JcIixcbiAgICAgIFwiaW5jbHVkZU1hcmdpblwiLFxuICAgICAgXCJtaW5WZXJzaW9uXCIsXG4gICAgICBcImJvb3N0TGV2ZWxcIixcbiAgICAgIFwibWFyZ2luU2l6ZVwiLFxuICAgICAgXCJpbWFnZVNldHRpbmdzXCJcbiAgICBdKTtcbiAgICBjb25zdCBfYiA9IGV4dHJhUHJvcHMsIHsgc3R5bGUgfSA9IF9iLCBvdGhlclByb3BzID0gX19vYmpSZXN0KF9iLCBbXCJzdHlsZVwiXSk7XG4gICAgY29uc3QgaW1nU3JjID0gaW1hZ2VTZXR0aW5ncyA9PSBudWxsID8gdm9pZCAwIDogaW1hZ2VTZXR0aW5ncy5zcmM7XG4gICAgY29uc3QgX2NhbnZhcyA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBfaW1hZ2UgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3Qgc2V0Q2FudmFzUmVmID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAobm9kZSkgPT4ge1xuICAgICAgICBfY2FudmFzLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIGZvcndhcmRlZFJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZm9yd2FyZGVkUmVmKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcndhcmRlZFJlZikge1xuICAgICAgICAgIGZvcndhcmRlZFJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtmb3J3YXJkZWRSZWZdXG4gICAgKTtcbiAgICBjb25zdCBbaXNJbWdMb2FkZWQsIHNldElzSW1hZ2VMb2FkZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgbWFyZ2luLCBjZWxscywgbnVtQ2VsbHMsIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzIH0gPSB1c2VRUkNvZGUoe1xuICAgICAgdmFsdWUsXG4gICAgICBsZXZlbCxcbiAgICAgIG1pblZlcnNpb24sXG4gICAgICBib29zdExldmVsLFxuICAgICAgaW5jbHVkZU1hcmdpbixcbiAgICAgIG1hcmdpblNpemUsXG4gICAgICBpbWFnZVNldHRpbmdzLFxuICAgICAgc2l6ZVxuICAgIH0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoX2NhbnZhcy5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gX2NhbnZhcy5jdXJyZW50O1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2VsbHNUb0RyYXcgPSBjZWxscztcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBfaW1hZ2UuY3VycmVudDtcbiAgICAgICAgY29uc3QgaGF2ZUltYWdlVG9SZW5kZXIgPSBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyAhPSBudWxsICYmIGltYWdlICE9PSBudWxsICYmIGltYWdlLmNvbXBsZXRlICYmIGltYWdlLm5hdHVyYWxIZWlnaHQgIT09IDAgJiYgaW1hZ2UubmF0dXJhbFdpZHRoICE9PSAwO1xuICAgICAgICBpZiAoaGF2ZUltYWdlVG9SZW5kZXIpIHtcbiAgICAgICAgICBpZiAoY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuZXhjYXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjZWxsc1RvRHJhdyA9IGV4Y2F2YXRlTW9kdWxlcyhcbiAgICAgICAgICAgICAgY2VsbHMsXG4gICAgICAgICAgICAgIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmV4Y2F2YXRpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoID0gc2l6ZSAqIHBpeGVsUmF0aW87XG4gICAgICAgIGNvbnN0IHNjYWxlID0gc2l6ZSAvIG51bUNlbGxzICogcGl4ZWxSYXRpbztcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBiZ0NvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgbnVtQ2VsbHMsIG51bUNlbGxzKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZnQ29sb3I7XG4gICAgICAgIGlmIChTVVBQT1JUU19QQVRIMkQpIHtcbiAgICAgICAgICBjdHguZmlsbChuZXcgUGF0aDJEKGdlbmVyYXRlUGF0aChjZWxsc1RvRHJhdywgbWFyZ2luKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNlbGxzLmZvckVhY2goZnVuY3Rpb24ocm93LCByZHgpIHtcbiAgICAgICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIGNkeCkge1xuICAgICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChjZHggKyBtYXJnaW4sIHJkeCArIG1hcmdpbiwgMSwgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncykge1xuICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhdmVJbWFnZVRvUmVuZGVyKSB7XG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MueCArIG1hcmdpbixcbiAgICAgICAgICAgIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLnkgKyBtYXJnaW4sXG4gICAgICAgICAgICBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy53LFxuICAgICAgICAgICAgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuaFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgc2V0SXNJbWFnZUxvYWRlZChmYWxzZSk7XG4gICAgfSwgW2ltZ1NyY10pO1xuICAgIGNvbnN0IGNhbnZhc1N0eWxlID0gX19zcHJlYWRWYWx1ZXMoeyBoZWlnaHQ6IHNpemUsIHdpZHRoOiBzaXplIH0sIHN0eWxlKTtcbiAgICBsZXQgaW1nID0gbnVsbDtcbiAgICBpZiAoaW1nU3JjICE9IG51bGwpIHtcbiAgICAgIGltZyA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBcImltZ1wiLFxuICAgICAgICB7XG4gICAgICAgICAgc3JjOiBpbWdTcmMsXG4gICAgICAgICAga2V5OiBpbWdTcmMsXG4gICAgICAgICAgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSxcbiAgICAgICAgICBvbkxvYWQ6ICgpID0+IHtcbiAgICAgICAgICAgIHNldElzSW1hZ2VMb2FkZWQodHJ1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWY6IF9pbWFnZSxcbiAgICAgICAgICBjcm9zc09yaWdpbjogY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmNyb3NzT3JpZ2luXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImNhbnZhc1wiLFxuICAgICAgX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICBzdHlsZTogY2FudmFzU3R5bGUsXG4gICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgd2lkdGg6IHNpemUsXG4gICAgICAgIHJlZjogc2V0Q2FudmFzUmVmLFxuICAgICAgICByb2xlOiBcImltZ1wiXG4gICAgICB9LCBvdGhlclByb3BzKVxuICAgICksIGltZyk7XG4gIH1cbik7XG5RUkNvZGVDYW52YXMuZGlzcGxheU5hbWUgPSBcIlFSQ29kZUNhbnZhc1wiO1xudmFyIFFSQ29kZVNWRyA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIGZ1bmN0aW9uIFFSQ29kZVNWRzIocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICAgIGNvbnN0IF9hID0gcHJvcHMsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgc2l6ZSA9IERFRkFVTFRfU0laRSxcbiAgICAgIGxldmVsID0gREVGQVVMVF9MRVZFTCxcbiAgICAgIGJnQ29sb3IgPSBERUZBVUxUX0JHQ09MT1IsXG4gICAgICBmZ0NvbG9yID0gREVGQVVMVF9GR0NPTE9SLFxuICAgICAgaW5jbHVkZU1hcmdpbiA9IERFRkFVTFRfSU5DTFVERU1BUkdJTixcbiAgICAgIG1pblZlcnNpb24gPSBERUZBVUxUX01JTlZFUlNJT04sXG4gICAgICBib29zdExldmVsLFxuICAgICAgdGl0bGUsXG4gICAgICBtYXJnaW5TaXplLFxuICAgICAgaW1hZ2VTZXR0aW5nc1xuICAgIH0gPSBfYSwgb3RoZXJQcm9wcyA9IF9fb2JqUmVzdChfYSwgW1xuICAgICAgXCJ2YWx1ZVwiLFxuICAgICAgXCJzaXplXCIsXG4gICAgICBcImxldmVsXCIsXG4gICAgICBcImJnQ29sb3JcIixcbiAgICAgIFwiZmdDb2xvclwiLFxuICAgICAgXCJpbmNsdWRlTWFyZ2luXCIsXG4gICAgICBcIm1pblZlcnNpb25cIixcbiAgICAgIFwiYm9vc3RMZXZlbFwiLFxuICAgICAgXCJ0aXRsZVwiLFxuICAgICAgXCJtYXJnaW5TaXplXCIsXG4gICAgICBcImltYWdlU2V0dGluZ3NcIlxuICAgIF0pO1xuICAgIGNvbnN0IHsgbWFyZ2luLCBjZWxscywgbnVtQ2VsbHMsIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzIH0gPSB1c2VRUkNvZGUoe1xuICAgICAgdmFsdWUsXG4gICAgICBsZXZlbCxcbiAgICAgIG1pblZlcnNpb24sXG4gICAgICBib29zdExldmVsLFxuICAgICAgaW5jbHVkZU1hcmdpbixcbiAgICAgIG1hcmdpblNpemUsXG4gICAgICBpbWFnZVNldHRpbmdzLFxuICAgICAgc2l6ZVxuICAgIH0pO1xuICAgIGxldCBjZWxsc1RvRHJhdyA9IGNlbGxzO1xuICAgIGxldCBpbWFnZSA9IG51bGw7XG4gICAgaWYgKGltYWdlU2V0dGluZ3MgIT0gbnVsbCAmJiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyAhPSBudWxsKSB7XG4gICAgICBpZiAoY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuZXhjYXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIGNlbGxzVG9EcmF3ID0gZXhjYXZhdGVNb2R1bGVzKFxuICAgICAgICAgIGNlbGxzLFxuICAgICAgICAgIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmV4Y2F2YXRpb25cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGltYWdlID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFwiaW1hZ2VcIixcbiAgICAgICAge1xuICAgICAgICAgIGhyZWY6IGltYWdlU2V0dGluZ3Muc3JjLFxuICAgICAgICAgIGhlaWdodDogY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuaCxcbiAgICAgICAgICB3aWR0aDogY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MudyxcbiAgICAgICAgICB4OiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy54ICsgbWFyZ2luLFxuICAgICAgICAgIHk6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLnkgKyBtYXJnaW4sXG4gICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCIsXG4gICAgICAgICAgb3BhY2l0eTogY2FsY3VsYXRlZEltYWdlU2V0dGluZ3Mub3BhY2l0eSxcbiAgICAgICAgICBjcm9zc09yaWdpbjogY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuY3Jvc3NPcmlnaW5cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZmdQYXRoID0gZ2VuZXJhdGVQYXRoKGNlbGxzVG9EcmF3LCBtYXJnaW4pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFwic3ZnXCIsXG4gICAgICBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgd2lkdGg6IHNpemUsXG4gICAgICAgIHZpZXdCb3g6IGAwIDAgJHtudW1DZWxsc30gJHtudW1DZWxsc31gLFxuICAgICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgICAgcm9sZTogXCJpbWdcIlxuICAgICAgfSwgb3RoZXJQcm9wcyksXG4gICAgICAhIXRpdGxlICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgbnVsbCwgdGl0bGUpLFxuICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFwicGF0aFwiLFxuICAgICAgICB7XG4gICAgICAgICAgZmlsbDogYmdDb2xvcixcbiAgICAgICAgICBkOiBgTTAsMCBoJHtudW1DZWxsc312JHtudW1DZWxsc31IMHpgLFxuICAgICAgICAgIHNoYXBlUmVuZGVyaW5nOiBcImNyaXNwRWRnZXNcIlxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZmlsbDogZmdDb2xvciwgZDogZmdQYXRoLCBzaGFwZVJlbmRlcmluZzogXCJjcmlzcEVkZ2VzXCIgfSksXG4gICAgICBpbWFnZVxuICAgICk7XG4gIH1cbik7XG5RUkNvZGVTVkcuZGlzcGxheU5hbWUgPSBcIlFSQ29kZVNWR1wiO1xuZXhwb3J0IHtcbiAgUVJDb2RlQ2FudmFzLFxuICBRUkNvZGVTVkdcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/qrcode.react/lib/esm/index.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Clucas%5C%5COneDrive%5C%5CDocumentos%5C%5CProjetos%5C%5CSGA%5C%5Cfrontend%5C%5Capp%5C%5Cpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);